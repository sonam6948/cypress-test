"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var cypress_cloud_exports = {};
__export(cypress_cloud_exports, {
  run: () => run2
});
module.exports = __toCommonJS(cypress_cloud_exports);

// ../../node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// index.ts
var import_register = require("source-map-support/register.js");

// lib/require.ts
var import_module = require("module");
var require2 = (0, import_module.createRequire)(importMetaUrl);

// lib/stdout.ts
var import_child_process = __toESM(require("child_process"));
var orginal = import_child_process.default.spawn;
import_child_process.default.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws/ws.ts
var import_debug = __toESM(require("debug"));
var import_http = __toESM(require("http"));
var import_lil_http_terminator = __toESM(require("lil-http-terminator"));
var import_ts_pattern = require("ts-pattern");
var WebSocket = __toESM(require("ws"));

// lib/pubsub.ts
var import_events = __toESM(require("events"));
var pubsub = new import_events.default();

// lib/ws/ws.ts
var debug = (0, import_debug.default)("currents:ws");
var server = null;
var wss = null;
var httpTerminator = null;
var getWSSPort = () => (0, import_ts_pattern.match)(server?.address()).with({ port: import_ts_pattern.P.number }, (address) => address.port).otherwise(() => 0);
var stopWSS = async () => {
  debug("terminating wss server: %d", getWSSPort());
  if (!httpTerminator) {
    debug("no wss server");
    return;
  }
  const { success, code, message, error: error2 } = await httpTerminator.terminate();
  if (!success) {
    if (code === "TIMED_OUT")
      error2(message);
    if (code === "SERVER_ERROR")
      error2(message, error2);
    if (code === "INTERNAL_ERROR")
      error2(message, error2);
  }
  debug("terminated wss server: %d", getWSSPort());
};
var startWSS = () => {
  if (wss) {
    return;
  }
  server = import_http.default.createServer().on("listening", () => {
    if (!server) {
      throw new Error("Server not initialized");
    }
    wss = new WebSocket.WebSocketServer({
      server
    });
    debug("starting wss on port %d", getWSSPort());
    wss.on("connection", function connection(ws) {
      ws.on("message", function incoming(event) {
        const message = JSON.parse(event.toString());
        pubsub.emit(message.type, message.payload);
      });
    });
  }).listen();
  httpTerminator = (0, import_lil_http_terminator.default)({
    server
  });
};

// lib/capture.ts
var import_debug2 = __toESM(require("debug"));
var debug2 = (0, import_debug2.default)("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug2("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug2("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/config.ts
var import_axios = require("axios");
var isRetriableError = (err) => {
  if (err.code === "ECONNABORTED") {
    return true;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  if (err.code === "ETIMEDOUT") {
    return true;
  }
  if (!(0, import_axios.isAxiosError)(err)) {
    return false;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [5 * 1e3, 10 * 1e3, 30 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
var import_axios2 = __toESM(require("axios"));
var import_axios_retry = __toESM(require("axios-retry"));
var import_debug7 = __toESM(require("debug"));
var import_lodash5 = __toESM(require("lodash"));
var import_pretty_ms = __toESM(require("pretty-ms"));

// lib/config/config.ts
var import_debug5 = __toESM(require("debug"));
var import_ts_pattern2 = require("ts-pattern");

// lib/bootstrap/bootstrap.ts
var import_cy2 = require("cy2");
var import_debug4 = __toESM(require("debug"));
var import_execa = __toESM(require("execa"));
var import_fs = __toESM(require("fs"));

// lib/errors.ts
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/fs.ts
var import_tmp_promise = require("tmp-promise");
var createTempFile = async () => {
  const { path: path4 } = await (0, import_tmp_promise.file)();
  return path4;
};

// lib/log.ts
var import_chalk = __toESM(require("chalk"));
var import_util = __toESM(require("util"));
var log = (...args) => console.log(import_util.default.format(...args));
var info = log;
var format = import_util.default.format;
var withError = (msg) => import_chalk.default.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => import_chalk.default.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(import_util.default.format(...args)));
var error = (...args) => log(withError(import_util.default.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + import_chalk.default[color].bold(import_util.default.format(...args)) + "  \n");
var divider = () => console.log("\n" + import_chalk.default.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = import_chalk.default.cyan;
var blue = import_chalk.default.blueBright;
var red = import_chalk.default.red;
var green = import_chalk.default.greenBright;
var gray = import_chalk.default.gray;
var white = import_chalk.default.white;
var magenta = import_chalk.default.magenta;
var bold = import_chalk.default.bold;
var yellow = import_chalk.default.yellow;
var dim = import_chalk.default.dim;

// lib/bootstrap/serializer.ts
var import_debug3 = __toESM(require("debug"));
var import_lodash = __toESM(require("lodash"));
var import_nanoid = require("nanoid");
var debug3 = (0, import_debug3.default)("currents:boot");
var getDummySpec = (0, import_nanoid.customAlphabet)("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  tempFilePath
}) {
  return import_lodash.default.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug3("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug3("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ...import_lodash.default.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (import_lodash.default.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug4 = (0, import_debug4.default)("currents:boot");
var bootCypress = async (params) => {
  debug4("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await (0, import_cy2.getBinPath)(require2.resolve("cypress"));
  debug4("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ tempFilePath, params });
  debug4("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!import_fs.default.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = import_fs.default.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug4("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug4("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await (0, import_execa.default)(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug4("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/config/path.ts
var import_is_absolute = __toESM(require("is-absolute"));
var import_lodash2 = __toESM(require("lodash"));
var import_path = __toESM(require("path"));
var defaultFilenames = [
  "currents.config.js",
  "currents.config.cjs",
  "currents.config.mjs"
];
function getConfigFilePath(projectRoot = null, explicitConfigFilePath) {
  const prefix = projectRoot ?? process.cwd();
  if (import_lodash2.default.isString(explicitConfigFilePath) && (0, import_is_absolute.default)(explicitConfigFilePath)) {
    return [explicitConfigFilePath];
  }
  if (import_lodash2.default.isString(explicitConfigFilePath)) {
    return [normalizePath(prefix, explicitConfigFilePath)];
  }
  return defaultFilenames.map((p) => normalizePath(prefix, p));
}
function normalizePath(prefix, filename) {
  return `file://${import_path.default.resolve(prefix, filename)}`;
}

// lib/config/config.ts
var debug5 = (0, import_debug5.default)("currents:config");
var _config = null;
var defaultConfig = {
  e2e: {
    batchSize: 3
  },
  component: {
    batchSize: 5
  },
  cloudServiceUrl: "https://cy.currents.dev",
  networkHeaders: void 0
};
async function getCurrentsConfig(projectRoot, explicitConfigFilePath) {
  if (_config) {
    return _config;
  }
  const configFilePath = getConfigFilePath(projectRoot, explicitConfigFilePath);
  for (const filepath of configFilePath) {
    const config = (0, import_ts_pattern2.match)(await loadConfigFile(filepath)).with({ default: import_ts_pattern2.P.not(import_ts_pattern2.P.nullish) }, (c) => c.default).with(import_ts_pattern2.P.not(import_ts_pattern2.P.nullish), (c) => c).otherwise(() => null);
    if (config) {
      debug5("loaded currents config from '%s'\n%O", filepath, config);
      info("Using config file: '%s'", filepath);
      _config = {
        ...defaultConfig,
        ...config
      };
      return _config;
    }
  }
  warn(
    "Failed to load config file, falling back to the default config. Attempted locations: %s",
    configFilePath
  );
  _config = defaultConfig;
  return _config;
}
async function loadConfigFile(filepath) {
  try {
    debug5("loading currents config file from '%s'", filepath);
    return await import(filepath);
  } catch (e) {
    debug5("failed loading config file from: %s", e);
    return null;
  }
}
async function getMergedConfig(params) {
  debug5("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(params);
  debug5("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig,
    experimentalCoverageRecording: params.experimentalCoverageRecording
  };
  debug5("merged config: %O", result);
  return result;
}

// lib/config/params.ts
var import_debug6 = __toESM(require("debug"));
var import_lodash3 = __toESM(require("lodash"));
var debug6 = (0, import_debug6.default)("currents:validateParams");
async function resolveCurrentsParams(params) {
  const configFromFile = await getCurrentsConfig(
    params.project,
    params.cloudConfigFile
  );
  debug6("resolving currents params: %o", params);
  debug6("resolving currents config file: %o", configFromFile);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.{c}js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.{c}js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.{c}js" file
`;
async function validateParams(_params) {
  const params = await resolveCurrentsParams(_params);
  debug6("validating currents params: %o", params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug6("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ...import_lodash3.default.pickBy(
      import_lodash3.default.omit(params, [
        "cloudDebug",
        "cloudConfigFile",
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headless",
        "experimentalCoverageRecording"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return import_lodash3.default.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/httpClient/printErrors.ts
var import_lodash4 = __toESM(require("lodash"));
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!import_lodash4.default.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug7 = (0, import_debug7.default)("currents:api");
var MAX_RETRIES = 3;
var TIMEOUT_MS = 30 * 1e3;
var _client = null;
async function getClient() {
  if (_client) {
    return _client;
  }
  const currentsConfig = await getCurrentsConfig();
  _client = import_axios2.default.create({
    baseURL: getAPIBaseUrl(),
    timeout: TIMEOUT_MS
  });
  _client.interceptors.request.use((config) => {
    const ccyVerson = _currentsVersion ?? "0.0.0";
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": ccyVerson,
      "User-Agent": `cypress-cloud/${ccyVerson}`
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    if (currentsConfig.networkHeaders) {
      const filteredHeaders = import_lodash5.default.omit(currentsConfig.networkHeaders, [
        "x-cypress-request-attempt",
        "x-cypress-version",
        "x-ccy-version",
        "x-cypress-run-id",
        "Content-Type"
      ]);
      debug7("using custom network headers: %o", filteredHeaders);
      Object.assign(headers, filteredHeaders);
    }
    const req = {
      ...config,
      headers
    };
    debug7("network request: %o", {
      ...import_lodash5.default.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  (0, import_axios_retry.default)(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry,
    shouldResetTimeout: true
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, config) {
  warn(
    "Network request '%s' failed: '%s'. Next attempt is in %s (%d/%d).",
    `${config.method} ${config.url}`,
    err.message,
    (0, import_pretty_ms.default)(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = async (config) => {
  return (await getClient())(config).then((res) => {
    debug7("network response: %o", import_lodash5.default.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
var import_debug21 = __toESM(require("debug"));
var import_plur = __toESM(require("plur"));

// legal.ts
function getLegalNotice() {
  return `
Copyright (C) ${(/* @__PURE__ */ new Date()).getFullYear()} Currents Software Inc https://currents.dev
This is free software, and you are welcome to redistribute it under certain
conditions. This program comes with no warranty. Parts of this program are MIT
licensed. Refer to the license for details
https://github.com/currents-dev/cypress-cloud/blob/main/LICENSE.md
`;
}

// lib/api/warnings.ts
var import_lodash6 = __toESM(require("lodash"));
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(import_lodash6.default.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/ciProvider.ts
var import_debug8 = __toESM(require("debug"));
var import_lodash7 = __toESM(require("lodash"));
var debug8 = (0, import_debug8.default)("currents:ci");
var join = (char, ...pieces) => {
  return import_lodash7.default.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return import_lodash7.default.set(obj, import_lodash7.default.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return import_lodash7.default.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return import_lodash7.default.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return import_lodash7.default.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return import_lodash7.default.findKey(CI_PROVIDERS, (value) => {
    if (import_lodash7.default.isString(value)) {
      return env[value];
    }
    if (import_lodash7.default.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return import_lodash7.default.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return import_lodash7.default.chain(_providerCiParams()).omitBy(import_lodash7.default.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug8("detected CI provider: %s", provider);
  debug8("detected CI params: %O", params);
  return {
    params,
    provider
  };
}
function getCommitDefaults(existingInfo) {
  debug8("git commit existing info");
  debug8(existingInfo);
  const commitParamsObj = getCommitParams();
  debug8("commit info from provider environment variables: %O", commitParamsObj);
  const combined = import_lodash7.default.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = import_lodash7.default.defaultTo(
        value || commitParamsObj[key],
        null
      );
    }
  );
  debug8("combined git and environment variables from provider");
  debug8(combined);
  return combined;
}

// lib/coverage/index.ts
var import_promises = __toESM(require("fs/promises"));
var import_path3 = require("path");
var getCoverageFilePath = async (coverageFile = "./.nyc_output/out.json") => {
  const path4 = (0, import_path3.join)(process.cwd(), coverageFile);
  try {
    await import_promises.default.access(path4);
    return {
      path: path4,
      error: false
    };
  } catch (error2) {
    return {
      path: path4,
      error: error2
    };
  }
};

// lib/cypress/cypress.ts
var import_cypress = __toESM(require("cypress"));
var import_debug9 = __toESM(require("debug"));
var import_lodash8 = __toESM(require("lodash"));

// lib/lang.ts
var import_bluebird = __toESM(require("bluebird"));
import_bluebird.default.Promise.config({
  cancellation: true
});
var BPromise = import_bluebird.default.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    return ifFaled(e);
  }
};

// lib/cypress/cypress.ts
var debug9 = (0, import_debug9.default)("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: import_lodash8.default.flatten(params.spec).join(",")
  };
  debug9("Running bare Cypress with params %o", p);
  return import_cypress.default.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: getWSSPort()
    },
    spec
  };
  debug9("running cypress with options %o", options);
  const result = await import_cypress.default.run(options);
  if (result.status === "failed") {
    warn('Cypress runner failed with message: "%s"', result.message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
  }
  debug9("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = (spec, cypressRunOptions) => safe(
  runSpecFile,
  (error2) => {
    const message = `Cypress runnner crashed with an error:
${error2.message}
${error2.stack}}`;
    debug9("cypress run exception %o", error2);
    warn('Cypress runner crashed: "%s"', message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    return {
      status: "failed",
      failures: 1,
      message
    };
  },
  () => {
  }
)(spec, cypressRunOptions);

// lib/debug/index.ts
var import_debug10 = __toESM(require("debug"));
var import_ts_pattern3 = require("ts-pattern");
function activateDebug(mode) {
  (0, import_ts_pattern3.match)(mode).with(import_ts_pattern3.P.instanceOf(Array), (i) => i.forEach(setDebugMode)).with(true, () => setDebugMode("all" /* All */)).with(
    import_ts_pattern3.P.union(
      "all" /* All */,
      "currents" /* Currents */,
      "cypress" /* Cypress */,
      "commit-info" /* CommitInfo */
    ),
    (i) => setDebugMode(i)
  ).otherwise(() => setDebugMode("none" /* None */));
}
function setDebugMode(mode) {
  if (mode === "none" /* None */) {
    return;
  }
  const tokens = new Set(process.env.DEBUG ? process.env.DEBUG.split(",") : []);
  (0, import_ts_pattern3.match)(mode).with("all" /* All */, () => {
    tokens.add("commit-info" /* CommitInfo */);
    tokens.add("currents:*" /* Currents */);
    tokens.add("cypress:*" /* Cypress */);
  }).with("currents" /* Currents */, () => tokens.add("currents:*" /* Currents */)).with("cypress" /* Cypress */, () => tokens.add("cypress:*" /* Cypress */)).with("commit-info" /* CommitInfo */, () => tokens.add("commit-info" /* CommitInfo */)).otherwise(() => {
  });
  import_debug10.default.enable(Array.from(tokens).join(","));
}

// lib/env.ts
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/git.ts
var import_commit_info = require("@currents/commit-info");
var getGitInfo = async (projectRoot) => {
  const commit = await (0, import_commit_info.commitInfo)(projectRoot);
  return getCommitDefaults({
    branch: commit.branch,
    remoteOrigin: commit.remote,
    authorEmail: commit.email,
    authorName: commit.author,
    message: commit.message,
    sha: commit.sha,
    ghaEventData: commit.ghaEventData
  });
};

// lib/platform/browser.ts
var import_debug11 = __toESM(require("debug"));
var debug11 = (0, import_debug11.default)("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug11(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug11("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug11("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
var import_debug12 = __toESM(require("debug"));
var import_getos = __toESM(require("getos"));
var import_os = require("os");
var import_util2 = require("util");
var debug12 = (0, import_debug12.default)("currents:platform");
var getOsVersion = async () => {
  if ((0, import_os.platform)() === "linux") {
    try {
      const linuxOs = await (0, import_util2.promisify)(import_getos.default)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return (0, import_os.release)();
      }
    } catch {
      return (0, import_os.release)();
    }
  }
  return (0, import_os.release)();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: (0, import_os.platform)(),
    osVersion,
    osCpus: (0, import_os.cpus)(),
    osMemory: {
      free: (0, import_os.freemem)(),
      total: (0, import_os.totalmem)()
    }
  };
  debug12("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/results.ts
var import_debug13 = __toESM(require("debug"));
var import_lodash9 = __toESM(require("lodash"));
var import_nanoid2 = require("nanoid");
var debug13 = (0, import_debug13.default)("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: (0, import_nanoid2.nanoid)()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult, coverageFilePath) => {
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    hasCoverage: !!coverageFilePath,
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? []
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? [],
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: import_lodash9.default.first(startItems),
    endedTestsAt: import_lodash9.default.last(endItems),
    ...import_lodash9.default.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
var getDummyFailedTest = (start, error2) => ({
  title: ["Unknown"],
  state: "failed",
  body: "// This test is automatically generated due to execution failure",
  displayError: error2,
  attempts: [
    {
      state: "failed",
      startedAt: start,
      duration: 0,
      videoTimestamp: 0,
      screenshots: [],
      error: {
        name: "CypressExecutionError",
        message: error2,
        stack: ""
      }
    }
  ]
});
function getFailedDummyResult(configState, {
  specs,
  error: error2
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    // @ts-ignore
    config: configState.getConfig() ?? {},
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: s,
        absolute: s,
        relativeToCommonRoot: s
      },
      tests: [getDummyFailedTest(start, error2)],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function getCypressRunResultForSpec(spec, cypressResult) {
  if (!isSuccessResult(cypressResult)) {
    return;
  }
  const run3 = cypressResult.runs.find((r) => r.spec.relative === spec);
  if (!run3) {
    return;
  }
  const stats = getStats(run3.stats);
  return {
    ...cypressResult,
    runs: [run3],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
var import_lodash10 = __toESM(require("lodash"));
var import_pretty_ms2 = __toESM(require("pretty-ms"));
var import_table = require("table");
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = import_lodash10.default.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray((0, import_pretty_ms2.default)(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return (0, import_table.table)(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray((0, import_pretty_ms2.default)(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = import_lodash10.default.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
var import_debug16 = __toESM(require("debug"));

// lib/artifacts.ts
var import_debug15 = __toESM(require("debug"));

// lib/upload.ts
var import_debug14 = __toESM(require("debug"));
var import_fs3 = __toESM(require("fs"));
var readFile = import_fs3.default.promises.readFile;
var debug14 = (0, import_debug14.default)("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
function uploadJson(file2, url) {
  return uploadFile(file2, url, "application/json");
}
async function uploadFile(file2, url, type) {
  debug14('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type,
      "Content-Disposition": `inline`
    }
  });
}

// lib/artifacts.ts
var debug15 = (0, import_debug15.default)("currents:artifacts");
async function uploadArtifacts({
  executionState,
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls,
  coverageFilePath,
  coverageUploadUrl
}) {
  debug15("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls,
    coverageFilePath,
    coverageUploadUrl
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length + (coverageUploadUrl ? 1 : 0);
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => {
        debug15("failed uploading video %s. Error: %o", videoPath, e);
        executionState.addWarning(
          `Failed uploading video ${videoPath}.
${dim(e)}`
        );
      },
      () => debug15("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug15(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          executionState.addWarning(
            `No upload URL for screenshot ${screenshot.path}`
          );
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => {
            debug15(
              "failed uploading screenshot %s. Error: %o",
              screenshot.path,
              e
            );
            executionState.addWarning(
              `Failed uploading screenshot ${screenshot.path}.
${dim(e)}`
            );
          },
          () => debug15("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
  if (coverageUploadUrl && coverageFilePath) {
    await safe(
      uploadJson,
      (e) => {
        debug15(
          "failed uploading coverage file %s. Error: %o",
          coverageFilePath,
          e
        );
        executionState.addWarning(
          `Failed uploading coverage file ${coverageFilePath}.
${dim(e)}`
        );
      },
      () => debug15("success uploading", coverageFilePath)
    )(coverageFilePath, coverageUploadUrl);
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/cancellation/cancellation.ts
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug16 = (0, import_debug16.default)("currents:results");
async function getReportResultsTask(instanceId, configState, executionState, stdout2, coverageFilePath) {
  const results = executionState.getInstanceResults(configState, instanceId);
  const run3 = results.runs[0];
  if (!run3) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run3, coverageFilePath);
  const instanceTests = getInstanceTestsPayload(run3, results.config);
  const { videoUploadUrl, screenshotUploadUrls, coverageUploadUrl, cloud } = await reportResults(instanceId, instanceTests, instanceResults);
  if (cloud?.shouldCancel) {
    debug16("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug16("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls,
    coverageUploadUrl
  });
  return Promise.all([
    uploadArtifacts({
      executionState,
      videoUploadUrl,
      videoPath: run3.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots,
      coverageUploadUrl,
      coverageFilePath
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug16("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/runner.ts
var import_debug18 = __toESM(require("debug"));

// lib/runner/reportTask.ts
var import_debug17 = __toESM(require("debug"));
var debug17 = (0, import_debug17.default)("currents:reportTask");
var reportTasks = [];
var createReportTask = (configState, executionState, instanceId) => {
  const instance = executionState.getInstance(instanceId);
  if (!instance) {
    error("Cannot find execution state for instance %s", instanceId);
    return;
  }
  if (instance.reportStartedAt) {
    debug17("Report task already created for instance %s", instanceId);
    return;
  }
  instance.reportStartedAt = /* @__PURE__ */ new Date();
  debug17("Creating report task for instanceId %s", instanceId);
  reportTasks.push(
    getReportResultsTask(
      instanceId,
      configState,
      executionState,
      instance.output ?? "no output captured",
      instance.coverageFilePath
    ).catch(error)
  );
};
var createReportTaskSpec = (configState, executionState, spec) => {
  const i = executionState.getSpec(spec);
  if (!i) {
    error("Cannot find execution state for spec %s", spec);
    return;
  }
  debug17("Creating report task for spec %s", spec);
  return createReportTask(configState, executionState, i.instanceId);
};

// lib/runner/runner.ts
var debug18 = (0, import_debug18.default)("currents:runner");
async function runTillDone(executionState, configState, {
  runId,
  groupId,
  machineId,
  platform: platform2,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch(executionState, configState, {
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params
    });
    if (!newTasks.length) {
      debug18("No more tasks to run. Uploads queue: %d", reportTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach(
      (t) => createReportTask(configState, executionState, t.instanceId)
    );
  }
}
async function runBatch(executionState, configState, {
  runMeta,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug18("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug18("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  batch.specs.forEach((i) => executionState.initInstance(i));
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths - user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still report the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  batch.specs.forEach((spec) => {
    executionState.setInstanceOutput(spec.instanceId, output);
    const specRunResult = getCypressRunResultForSpec(spec.spec, rawResult);
    if (!specRunResult) {
      return;
    }
    executionState.setInstanceResult(
      configState,
      spec.instanceId,
      specRunResult
    );
  });
  resetCapture();
  return batch.specs;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(void 0));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(void 0);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/shutdown.ts
async function shutdown() {
  await stopWSS();
}

// lib/specMatcher/specMatcher.ts
var import_debug19 = __toESM(require("debug"));
var import_path5 = __toESM(require("path"));
var import_common_path_prefix = __toESM(require("common-path-prefix"));
var import_globby = __toESM(require("globby"));
var import_lodash11 = __toESM(require("lodash"));
var import_os2 = __toESM(require("os"));

// lib/utils.ts
var import_path4 = __toESM(require("path"));
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = import_path4.default.sep) {
  return file2.split(sep).join(import_path4.default.posix.sep);
}

// lib/specMatcher/specMatcher.ts
var debug19 = (0, import_debug19.default)("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug19("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!import_lodash11.default.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = import_lodash11.default.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = import_path5.default.join(projectRoot, import_path5.default.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (import_os2.default.platform() === "win32") {
    debug19("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug19("globbing pattern(s): %o", globs);
    debug19("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug19("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await (0, import_globby.default)(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug19("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = import_path5.default.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = (0, import_common_path_prefix.default)(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: import_os2.default.platform(),
      sep: import_path5.default.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = import_path5.default.relative(projectRoot, absolute);
  const parsedFile = import_path5.default.parse(absolute);
  const fileExtension = import_path5.default.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/state/config.ts
var ConfigState = class {
  constructor() {
    this._config = void 0;
  }
  setConfig(c) {
    this._config = c;
  }
  getConfig() {
    return this._config;
  }
};

// lib/results/mapResult.ts
function getScreenshot(s) {
  return {
    ...s,
    name: s.name ?? "screenshot"
  };
}
function getTestAttempt2(attempt, screenshots) {
  return {
    ...attempt,
    startedAt: attempt.wallClockStartedAt,
    duration: attempt.wallClockDuration,
    screenshots: screenshots.map(getScreenshot)
  };
}
function getTest(t, screenshots) {
  const _screenshots = screenshots.filter((s) => s.testId === t.testId);
  return {
    ...t,
    attempts: t.attempts.map(
      (a, i) => getTestAttempt2(
        a,
        _screenshots.filter((s) => s.testAttemptIndex === i)
      )
    )
  };
}
function specResultsToCypressResults(configState, specAfterResult) {
  return {
    status: "finished",
    // @ts-ignore
    config: configState.getConfig(),
    totalDuration: specAfterResult.stats.wallClockDuration,
    totalSuites: specAfterResult.stats.suites,
    totalTests: specAfterResult.stats.tests,
    totalFailed: specAfterResult.stats.failures,
    totalPassed: specAfterResult.stats.passes,
    totalPending: specAfterResult.stats.pending,
    totalSkipped: specAfterResult.stats.skipped,
    startedTestsAt: specAfterResult.stats.wallClockStartedAt,
    endedTestsAt: specAfterResult.stats.wallClockEndedAt,
    runs: [
      {
        stats: {
          ...specAfterResult.stats,
          startedAt: specAfterResult.stats.wallClockStartedAt,
          endedAt: specAfterResult.stats.wallClockEndedAt,
          duration: specAfterResult.stats.wallClockDuration
        },
        reporter: specAfterResult.reporter,
        reporterStats: specAfterResult.reporterStats ?? {},
        spec: specAfterResult.spec,
        error: specAfterResult.error,
        video: specAfterResult.video,
        shouldUploadVideo: true,
        // not really used
        // @ts-ignore
        // wrong typedef for CypressCommandLine.CypressRunResult
        // actual HookName is "before all" | "before each" | "after all" | "after each"
        hooks: specAfterResult.hooks,
        tests: (specAfterResult.tests ?? []).map(
          (t) => getTest(t, specAfterResult.screenshots)
        )
      }
    ]
  };
}
var backfillException = (result) => {
  return {
    ...result,
    runs: result.runs.map(backfillExceptionRun)
  };
};
var backfillExceptionRun = (run3) => {
  if (!run3.error) {
    return run3;
  }
  return {
    ...run3,
    tests: [getFakeTestFromException(run3.error, run3.stats)]
  };
};

// lib/state/execution.ts
var import_debug20 = __toESM(require("debug"));
var debug20 = (0, import_debug20.default)("currents:state");
var ExecutionState = class {
  constructor() {
    this.warnings = /* @__PURE__ */ new Set();
    this.state = {};
  }
  getWarnings() {
    return this.warnings;
  }
  addWarning(warning) {
    this.warnings.add(warning);
  }
  getResults(configState) {
    return Object.values(this.state).map(
      (i) => this.getInstanceResults(configState, i.instanceId)
    );
  }
  getInstance(instanceId) {
    return this.state[instanceId];
  }
  getSpec(spec) {
    return Object.values(this.state).find((i) => i.spec === spec);
  }
  initInstance({
    instanceId,
    spec
  }) {
    debug20('Init execution state for "%s"', spec);
    this.state[instanceId] = {
      instanceId,
      spec,
      createdAt: /* @__PURE__ */ new Date()
    };
  }
  setSpecBefore(spec) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specBefore = /* @__PURE__ */ new Date();
  }
  setSpecCoverage(spec, coverageFilePath) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    debug20("Experimental: coverageFilePath was set");
    i.coverageFilePath = coverageFilePath;
  }
  setSpecAfter(spec, results) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specAfter = /* @__PURE__ */ new Date();
    i.specAfterResults = results;
  }
  setSpecOutput(spec, output) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    this.setInstanceOutput(i.instanceId, output);
  }
  setInstanceOutput(instanceId, output) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    if (i.output) {
      debug20('Instance "%s" already has output', instanceId);
      return;
    }
    i.output = output;
  }
  setInstanceResult(configState, instanceId, results) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    i.runResults = results;
    i.runResultsReportedAt = /* @__PURE__ */ new Date();
  }
  getInstanceResults(configState, instanceId) {
    const i = this.getInstance(instanceId);
    if (!i) {
      error('Cannot find execution state for instance "%s"', instanceId);
      return getFailedDummyResult(configState, {
        specs: ["unknown"],
        error: "Cannot find execution state for instance"
      });
    }
    if (i.specAfterResults) {
      return backfillException(
        specResultsToCypressResults(configState, i.specAfterResults)
      );
    }
    if (i.runResults) {
      return backfillException(i.runResults);
    }
    debug20('No results detected for "%s"', i.spec);
    return getFailedDummyResult(configState, {
      specs: [i.spec],
      error: `No results detected for the spec file. That usually happens because of cypress crash. See the console output for details.`
    });
  }
};

// lib/run.ts
var debug21 = (0, import_debug21.default)("currents:run");
async function run(params = {}) {
  const executionState = new ExecutionState();
  const configState = new ConfigState();
  activateDebug(params.cloudDebug);
  debug21("run params %o", params);
  params = preprocessParams(params);
  debug21("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = await validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  if (!isCurrents()) {
    console.log(getLegalNotice());
  }
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    experimentalCoverageRecording
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  configState.setConfig(config?.resolved);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run3 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    coverageEnabled: experimentalCoverageRecording
  });
  setRunId(run3.runId);
  info("\u{1F3A5} Run URL:", bold(run3.runUrl));
  cutInitialOutput();
  await startWSS();
  listenToSpecEvents(
    configState,
    executionState,
    config.experimentalCoverageRecording
  );
  await runTillDoneOrCancelled(
    executionState,
    configState,
    {
      runId: run3.runId,
      groupId: run3.groupId,
      machineId: run3.machineId,
      platform: platform2,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(reportTasks);
  const _summary = summarizeTestResults(
    executionState.getResults(configState),
    config
  );
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  printWarnings2(executionState);
  info("\n\u{1F3C1} Recorded Run:", bold(run3.runUrl));
  await shutdown();
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run3.runUrl
    };
  }
  return _summary;
}
function listenToSpecEvents(configState, executionState, experimentalCoverageRecording) {
  const config = configState.getConfig();
  pubsub.on("before:spec", async ({ spec }) => {
    debug21("before:spec %o", spec);
    executionState.setSpecBefore(spec.relative);
  });
  pubsub.on(
    "after:spec",
    async ({ spec, results }) => {
      debug21("after:spec %o %o", spec, results);
      executionState.setSpecAfter(spec.relative, results);
      executionState.setSpecOutput(spec.relative, getCapturedOutput());
      if (experimentalCoverageRecording) {
        const { path: path4, error: error2 } = await getCoverageFilePath(
          config?.env?.coverageFile
        );
        if (!error2) {
          executionState.setSpecCoverage(spec.relative, path4);
        } else {
          executionState.addWarning(
            `Could not process coverage file "${path4}"
${dim(error2)}`
          );
        }
      }
      createReportTaskSpec(configState, executionState, spec.relative);
    }
  );
}
function printWarnings2(executionState) {
  const warnings = Array.from(executionState.getWarnings());
  if (warnings.length > 0) {
    warn(
      `${warnings.length} ${(0, import_plur.default)(
        "Warning",
        warnings.length
      )} encountered during the execution:
${warnings.map((w, i) => `
${yellow(`[${i + 1}/${warnings.length}]`)} ${w}`).join("\n")}`
    );
  }
}

// index.ts
function run2(params) {
  return run(params);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  run
});
/*! @preserve

### MIT

Parts of this code was copied from https://github.com/cypress-io/cypress and is subject to MIT license.

MIT License

Copyright (c) 2022 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5kZXgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzdXAvYXNzZXRzL2Nqc19zaGltcy5qcyIsICIuLi9saWIvcmVxdWlyZS50cyIsICIuLi9saWIvc3Rkb3V0LnRzIiwgIi4uL2xpYi93cy93cy50cyIsICIuLi9saWIvcHVic3ViLnRzIiwgIi4uL2xpYi9jYXB0dXJlLnRzIiwgIi4uL2xpYi9odHRwQ2xpZW50L2NvbmZpZy50cyIsICIuLi9saWIvaHR0cENsaWVudC9odHRwQ2xpZW50LnRzIiwgIi4uL2xpYi9jb25maWcvY29uZmlnLnRzIiwgIi4uL2xpYi9ib290c3RyYXAvYm9vdHN0cmFwLnRzIiwgIi4uL2xpYi9lcnJvcnMudHMiLCAiLi4vbGliL2ZzLnRzIiwgIi4uL2xpYi9sb2cudHMiLCAiLi4vbGliL2Jvb3RzdHJhcC9zZXJpYWxpemVyLnRzIiwgIi4uL2xpYi9jb25maWcvcGF0aC50cyIsICIuLi9saWIvY29uZmlnL3BhcmFtcy50cyIsICIuLi9saWIvaHR0cENsaWVudC9wcmludEVycm9ycy50cyIsICIuLi9saWIvaW5pdC50cyIsICIuLi9saWIvcnVuLnRzIiwgIi4uL2xlZ2FsLnRzIiwgIi4uL2xpYi9hcGkvd2FybmluZ3MudHMiLCAiLi4vbGliL2FwaS9hcGkudHMiLCAiLi4vbGliL2NpUHJvdmlkZXIudHMiLCAiLi4vbGliL2NvdmVyYWdlL2luZGV4LnRzIiwgIi4uL2xpYi9jeXByZXNzL2N5cHJlc3MudHMiLCAiLi4vbGliL2xhbmcudHMiLCAiLi4vbGliL2RlYnVnL2luZGV4LnRzIiwgIi4uL2xpYi9lbnYudHMiLCAiLi4vbGliL2dpdC50cyIsICIuLi9saWIvcGxhdGZvcm0vYnJvd3Nlci50cyIsICIuLi9saWIvcGxhdGZvcm0vcGxhdGZvcm0udHMiLCAiLi4vbGliL3BsYXRmb3JtL2luZGV4LnRzIiwgIi4uL2xpYi9yZXN1bHRzL3Jlc3VsdHMudHMiLCAiLi4vbGliL3Jlc3VsdHMvdGFibGUudHMiLCAiLi4vbGliL3Jlc3VsdHMvdXBsb2FkUmVzdWx0cy50cyIsICIuLi9saWIvYXJ0aWZhY3RzLnRzIiwgIi4uL2xpYi91cGxvYWQudHMiLCAiLi4vbGliL2NhbmNlbGxhdGlvbi9jYW5jZWxsYXRpb24udHMiLCAiLi4vbGliL3J1bm5lci9ydW5uZXIudHMiLCAiLi4vbGliL3J1bm5lci9yZXBvcnRUYXNrLnRzIiwgIi4uL2xpYi9ydW5uZXIvY2FuY2VsbGFibGUudHMiLCAiLi4vbGliL3NodXRkb3duLnRzIiwgIi4uL2xpYi9zcGVjTWF0Y2hlci9zcGVjTWF0Y2hlci50cyIsICIuLi9saWIvdXRpbHMudHMiLCAiLi4vbGliL3NwZWNNYXRjaGVyL2dldFNwZWNGaWxlcy50cyIsICIuLi9saWIvc3RhdGUvY29uZmlnLnRzIiwgIi4uL2xpYi9yZXN1bHRzL21hcFJlc3VsdC50cyIsICIuLi9saWIvc3RhdGUvZXhlY3V0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImN5cHJlc3NcIiAvPlxuaW1wb3J0IFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzXCI7XG5cbmltcG9ydCB7IHJ1biBhcyBpbnRlcm5hbFJ1biB9IGZyb20gXCIuL2xpYi9ydW5cIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuQVBJIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB0eXBlIHsgQ3VycmVudHNSdW5BUEkgfSBmcm9tIFwiLi90eXBlc1wiO1xuLyoqXG4gKiBSdW4gQ3lwcmVzcyB0ZXN0cyB3aXRoIGEgY2xvdWQgc2VydmljZSBvZiB5b3VyIGNob2ljZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRzXG4gKlxuICogQGF1Z21lbnRzIEN1cnJlbnRzUnVuQVBJXG4gKiBAcmV0dXJucyB7Q3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgfCBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc0ZhaWxlZFJ1blJlc3VsdCB8IHVuZGVmaW5lZH0gVGhlIHRlc3QgcmVzdWx0cywgb3IgdW5kZWZpbmVkIGlmIG5vIHRlc3RzIHdlcmUgcnVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4ocGFyYW1zPzogQ3VycmVudHNSdW5BUEkpIHtcbiAgcmV0dXJuIGludGVybmFsUnVuKHBhcmFtcyk7XG59XG4iLCAiLy8gU2hpbSBnbG9iYWxzIGluIGNqcyBidW5kbGVcbi8vIFRoZXJlJ3MgYSB3ZWlyZCBidWcgdGhhdCBlc2J1aWxkIHdpbGwgYWx3YXlzIGluamVjdCBpbXBvcnRNZXRhVXJsXG4vLyBpZiB3ZSBleHBvcnQgaXQgYXMgYGNvbnN0IGltcG9ydE1ldGFVcmwgPSAuLi4gX19maWxlbmFtZSAuLi5gXG4vLyBCdXQgdXNpbmcgYSBmdW5jdGlvbiB3aWxsIG5vdCBjYXVzZSB0aGlzIGlzc3VlXG5cbmNvbnN0IGdldEltcG9ydE1ldGFVcmwgPSAoKSA9PlxuICB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgPyBuZXcgVVJMKCdmaWxlOicgKyBfX2ZpbGVuYW1lKS5ocmVmXG4gICAgOiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYykgfHxcbiAgICAgIG5ldyBVUkwoJ21haW4uanMnLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmXG5cbmV4cG9ydCBjb25zdCBpbXBvcnRNZXRhVXJsID0gLyogQF9fUFVSRV9fICovIGdldEltcG9ydE1ldGFVcmwoKVxuIiwgImltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tIFwibW9kdWxlXCI7XG4vLyByZXF1aXJlcyBzaGltPXRydWUgaW4gcGFja2FnZS5qc29uXG5leHBvcnQgY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiIsICJpbXBvcnQgY3AgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmNvbnN0IG9yZ2luYWwgPSBjcC5zcGF3bjtcblxuLy8gQHRzLWlnbm9yZVxuY3Auc3Bhd24gPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncywgb3B0aW9ucykge1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChjb21tYW5kLm1hdGNoKC9DeXByZXNzLykpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcHJvY2VzcyA9IG9yZ2luYWwoY29tbWFuZCwgYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIHVzaW5nIHBpcGUgZW5hYmxlcyBjYXB0dXJpbmcgc3Rkb3V0IGFuZCBzdGRlcnJcbiAgICAgIHN0ZGlvOiBbXCJwaXBlXCIsIFwicGlwZVwiLCBcInBpcGVcIl0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3M7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBvcmdpbmFsKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xufTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgaHR0cCBmcm9tIFwiaHR0cFwiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IEh0dHBUZXJtaW5hdG9yIGZyb20gXCJsaWwtaHR0cC10ZXJtaW5hdG9yXCI7XG5pbXBvcnQgeyBtYXRjaCwgUCB9IGZyb20gXCJ0cy1wYXR0ZXJuXCI7XG5pbXBvcnQgKiBhcyBXZWJTb2NrZXQgZnJvbSBcIndzXCI7XG5pbXBvcnQgeyBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp3c1wiKTtcblxubGV0IHNlcnZlcjogaHR0cC5TZXJ2ZXIgfCBudWxsID0gbnVsbDtcbmxldCB3c3M6IFdlYlNvY2tldC5TZXJ2ZXIgfCBudWxsID0gbnVsbDtcbmxldCBodHRwVGVybWluYXRvcjogSHR0cFRlcm1pbmF0b3IgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGdldFdTU1BvcnQgPSAoKSA9PlxuICBtYXRjaChzZXJ2ZXI/LmFkZHJlc3MoKSlcbiAgICAud2l0aCh7IHBvcnQ6IFAubnVtYmVyIH0sIChhZGRyZXNzKSA9PiBhZGRyZXNzLnBvcnQpXG4gICAgLm90aGVyd2lzZSgoKSA9PiAwKTtcblxuZXhwb3J0IGNvbnN0IHN0b3BXU1MgPSBhc3luYyAoKSA9PiB7XG4gIGRlYnVnKFwidGVybWluYXRpbmcgd3NzIHNlcnZlcjogJWRcIiwgZ2V0V1NTUG9ydCgpKTtcbiAgaWYgKCFodHRwVGVybWluYXRvcikge1xuICAgIGRlYnVnKFwibm8gd3NzIHNlcnZlclwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyBzdWNjZXNzLCBjb2RlLCBtZXNzYWdlLCBlcnJvciB9ID0gYXdhaXQgaHR0cFRlcm1pbmF0b3IudGVybWluYXRlKCk7XG4gIGlmICghc3VjY2Vzcykge1xuICAgIGlmIChjb2RlID09PSBcIlRJTUVEX09VVFwiKSBlcnJvcihtZXNzYWdlKTtcbiAgICBpZiAoY29kZSA9PT0gXCJTRVJWRVJfRVJST1JcIikgZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICAgIGlmIChjb2RlID09PSBcIklOVEVSTkFMX0VSUk9SXCIpIGVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgfVxuICBkZWJ1ZyhcInRlcm1pbmF0ZWQgd3NzIHNlcnZlcjogJWRcIiwgZ2V0V1NTUG9ydCgpKTtcbn07XG5leHBvcnQgY29uc3Qgc3RhcnRXU1MgPSAoKSA9PiB7XG4gIGlmICh3c3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VydmVyID0gaHR0cFxuICAgIC5jcmVhdGVTZXJ2ZXIoKVxuICAgIC5vbihcImxpc3RlbmluZ1wiLCAoKSA9PiB7XG4gICAgICBpZiAoIXNlcnZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2ZXIgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgfVxuICAgICAgd3NzID0gbmV3IFdlYlNvY2tldC5XZWJTb2NrZXRTZXJ2ZXIoe1xuICAgICAgICBzZXJ2ZXIsXG4gICAgICB9KTtcbiAgICAgIGRlYnVnKFwic3RhcnRpbmcgd3NzIG9uIHBvcnQgJWRcIiwgZ2V0V1NTUG9ydCgpKTtcbiAgICAgIHdzcy5vbihcImNvbm5lY3Rpb25cIiwgZnVuY3Rpb24gY29ubmVjdGlvbih3cykge1xuICAgICAgICB3cy5vbihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gaW5jb21pbmcoZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC50b1N0cmluZygpKTtcbiAgICAgICAgICBwdWJzdWIuZW1pdChtZXNzYWdlLnR5cGUsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAubGlzdGVuKCk7XG5cbiAgaHR0cFRlcm1pbmF0b3IgPSBIdHRwVGVybWluYXRvcih7XG4gICAgc2VydmVyLFxuICB9KTtcbn07XG4iLCAiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiZXZlbnRzXCI7XG5leHBvcnQgZW51bSBFdmVudCB7XG4gIFJVTl9DQU5DRUxMRUQgPSBcInJ1bkNhbmNlbGxlZFwiLFxufVxuZXhwb3J0IGNvbnN0IHB1YnN1YiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Y2FwdHVyZVwiKTtcblxuY29uc3QgX3dyaXRlID0gcHJvY2Vzcy5zdGRvdXQud3JpdGU7XG5jb25zdCBfbG9nID0gcHJvY2Vzcy5sb2c7XG5cbmV4cG9ydCBjb25zdCByZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAvLyByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbHNcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBfd3JpdGU7XG4gIHByb2Nlc3MubG9nID0gX2xvZztcbn07XG5cbmNvbnN0IGxvZ3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuXG5jb25zdCBzdGRvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKFwiY2FwdHVyaW5nIHN0ZG91dFwiKTtcbiAgbGV0IGxvZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gbGF6aWx5IGJhY2t1cCB3cml0ZSB0byBlbmFibGUgaW5qZWN0aW9uXG4gIGNvbnN0IHsgd3JpdGUgfSA9IHByb2Nlc3Muc3Rkb3V0O1xuICBjb25zdCB7IGxvZyB9ID0gcHJvY2VzcztcblxuICAvLyBlbGVjdHJvbiBhZGRzIGEgbmV3IHByb2Nlc3MubG9nXG4gIC8vIG1ldGhvZCBmb3Igd2luZG93cyBpbnN0ZWFkIG9mIHByb2Nlc3Muc3Rkb3V0LndyaXRlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvaXNzdWVzLzk3N1xuICBpZiAobG9nKSB7XG4gICAgcHJvY2Vzcy5sb2cgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpIHtcbiAgICAgIGxvZ3MucHVzaChzdHIpO1xuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICByZXR1cm4gbG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKSB7XG4gICAgbG9ncy5wdXNoKHN0cik7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIHJldHVybiB3cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gbG9ncy5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgZGF0YTogbG9ncyxcbiAgICByZXN0b3JlLFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICBkZWJ1ZyhcInJlc2V0dGluZyBjYXB0dXJlZCBzdGRvdXRcIik7XG4gICAgICBsb2dzID0gW107XG4gICAgfSxcbiAgfTtcbn07XG5cbmxldCBpbml0aWFsT3V0cHV0OiBzdHJpbmcgPSBcIlwiO1xubGV0IGNhcHR1cmVkT3V0cHV0OiBudWxsIHwgUmV0dXJuVHlwZTx0eXBlb2Ygc3Rkb3V0PiA9IG51bGw7XG5cbmV4cG9ydCBjb25zdCBpbml0Q2FwdHVyZSA9ICgpID0+IChjYXB0dXJlZE91dHB1dCA9IHN0ZG91dCgpKTtcblxuZXhwb3J0IGNvbnN0IGN1dEluaXRpYWxPdXRwdXQgPSAoKSA9PiB7XG4gIGlmICghY2FwdHVyZWRPdXRwdXQpIHRocm93IG5ldyBFcnJvcihcImNhcHR1cmVkT3V0cHV0IGlzIG51bGxcIik7XG4gIGluaXRpYWxPdXRwdXQgPSBjYXB0dXJlZE91dHB1dC50b1N0cmluZygpO1xuICBjYXB0dXJlZE91dHB1dC5yZXNldCgpO1xufTtcbmV4cG9ydCBjb25zdCByZXNldENhcHR1cmUgPSAoKSA9PiB7XG4gIGlmICghY2FwdHVyZWRPdXRwdXQpIHRocm93IG5ldyBFcnJvcihcImNhcHR1cmVkT3V0cHV0IGlzIG51bGxcIik7XG4gIGNhcHR1cmVkT3V0cHV0LnJlc2V0KCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FwdHVyZWRPdXRwdXQgPSAoKSA9PiB7XG4gIGlmICghY2FwdHVyZWRPdXRwdXQpIHRocm93IG5ldyBFcnJvcihcImNhcHR1cmVkT3V0cHV0IGlzIG51bGxcIik7XG4gIHJldHVybiBjYXB0dXJlZE91dHB1dC50b1N0cmluZygpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsT3V0cHV0ID0gKCkgPT4gaW5pdGlhbE91dHB1dDtcbiIsICJpbXBvcnQgeyBBeGlvc0Vycm9yLCBpc0F4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcblxuZXhwb3J0IGNvbnN0IGlzUmV0cmlhYmxlRXJyb3IgPSAoZXJyOiBBeGlvc0Vycm9yKTogYm9vbGVhbiA9PiB7XG4gIGlmIChlcnIuY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIuY29kZSA9PT0gXCJFVElNRURPVVRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFpc0F4aW9zRXJyb3IoZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIShcbiAgICBlcnI/LnJlc3BvbnNlPy5zdGF0dXMgJiZcbiAgICA1MDAgPD0gZXJyLnJlc3BvbnNlLnN0YXR1cyAmJlxuICAgIGVyci5yZXNwb25zZS5zdGF0dXMgPCA2MDBcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREZWxheSA9IChpOiBudW1iZXIpID0+IFs1ICogMTAwMCwgMTAgKiAxMDAwLCAzMCAqIDEwMDBdW2kgLSAxXTtcblxubGV0IGJhc2VVUkwgPSBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG5leHBvcnQgY29uc3QgZ2V0QVBJQmFzZVVybCA9ICgpID0+IGJhc2VVUkwgPz8gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuZXhwb3J0IGNvbnN0IHNldEFQSUJhc2VVcmwgPSAodXJsPzogc3RyaW5nKSA9PlxuICAoYmFzZVVSTCA9IHVybCA/PyBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCIpO1xuIiwgImltcG9ydCBheGlvcywge1xuICBBeGlvc0Vycm9yLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWcsXG4gIEF4aW9zUmVzcG9uc2UsXG4gIFJhd0F4aW9zUmVxdWVzdEhlYWRlcnMsXG59IGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IGF4aW9zUmV0cnkgZnJvbSBcImF4aW9zLXJldHJ5XCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgcHJldHR5TWlsbGlzZWNvbmRzIGZyb20gXCJwcmV0dHktbXNcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRzQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEFQSUJhc2VVcmwsIGdldERlbGF5LCBpc1JldHJpYWJsZUVycm9yIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgeyBtYXliZVByaW50RXJyb3JzIH0gZnJvbSBcIi4vcHJpbnRFcnJvcnNcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmFwaVwiKTtcblxuY29uc3QgTUFYX1JFVFJJRVMgPSAzO1xuY29uc3QgVElNRU9VVF9NUyA9IDMwICogMTAwMDtcbmxldCBfY2xpZW50OiBBeGlvc0luc3RhbmNlIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDbGllbnQoKSB7XG4gIGlmIChfY2xpZW50KSB7XG4gICAgcmV0dXJuIF9jbGllbnQ7XG4gIH1cbiAgY29uc3QgY3VycmVudHNDb25maWcgPSBhd2FpdCBnZXRDdXJyZW50c0NvbmZpZygpO1xuICBfY2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgICBiYXNlVVJMOiBnZXRBUElCYXNlVXJsKCksXG4gICAgdGltZW91dDogVElNRU9VVF9NUyxcbiAgfSk7XG5cbiAgX2NsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGNjeVZlcnNvbiA9IF9jdXJyZW50c1ZlcnNpb24gPz8gXCIwLjAuMFwiO1xuICAgIGNvbnN0IGhlYWRlcnM6IFJhd0F4aW9zUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIFwieC1jeXByZXNzLXJlcXVlc3QtYXR0ZW1wdFwiOiBjb25maWdbXCJheGlvcy1yZXRyeVwiXT8ucmV0cnlDb3VudCA/PyAwLFxuICAgICAgXCJ4LWN5cHJlc3MtdmVyc2lvblwiOiBfY3lwcmVzc1ZlcnNpb24gPz8gXCIwLjAuMFwiLFxuICAgICAgXCJ4LWNjeS12ZXJzaW9uXCI6IGNjeVZlcnNvbixcbiAgICAgIFwiVXNlci1BZ2VudFwiOiBgY3lwcmVzcy1jbG91ZC8ke2NjeVZlcnNvbn1gLFxuICAgIH07XG4gICAgaWYgKF9ydW5JZCkge1xuICAgICAgaGVhZGVyc1tcIngtY3lwcmVzcy1ydW4taWRcIl0gPSBfcnVuSWQ7XG4gICAgfVxuICAgIGlmICghaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50c0NvbmZpZy5uZXR3b3JrSGVhZGVycykge1xuICAgICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gXy5vbWl0KGN1cnJlbnRzQ29uZmlnLm5ldHdvcmtIZWFkZXJzLCBbXG4gICAgICAgIFwieC1jeXByZXNzLXJlcXVlc3QtYXR0ZW1wdFwiLFxuICAgICAgICBcIngtY3lwcmVzcy12ZXJzaW9uXCIsXG4gICAgICAgIFwieC1jY3ktdmVyc2lvblwiLFxuICAgICAgICBcIngtY3lwcmVzcy1ydW4taWRcIixcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIixcbiAgICAgIF0pO1xuICAgICAgZGVidWcoXCJ1c2luZyBjdXN0b20gbmV0d29yayBoZWFkZXJzOiAlb1wiLCBmaWx0ZXJlZEhlYWRlcnMpO1xuICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBmaWx0ZXJlZEhlYWRlcnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfTtcblxuICAgIGRlYnVnKFwibmV0d29yayByZXF1ZXN0OiAlb1wiLCB7XG4gICAgICAuLi5fLnBpY2socmVxLCBcIm1ldGhvZFwiLCBcInVybFwiLCBcImhlYWRlcnNcIiksXG4gICAgICBkYXRhOiBCdWZmZXIuaXNCdWZmZXIocmVxLmRhdGEpID8gXCJidWZmZXJcIiA6IHJlcS5kYXRhLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcTtcbiAgfSk7XG5cbiAgYXhpb3NSZXRyeShfY2xpZW50LCB7XG4gICAgcmV0cmllczogTUFYX1JFVFJJRVMsXG4gICAgcmV0cnlDb25kaXRpb246IGlzUmV0cmlhYmxlRXJyb3IsXG4gICAgcmV0cnlEZWxheTogZ2V0RGVsYXksXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG9uUmV0cnksXG4gICAgc2hvdWxkUmVzZXRUaW1lb3V0OiB0cnVlLFxuICB9KTtcbiAgcmV0dXJuIF9jbGllbnQ7XG59XG5cbmxldCBfcnVuSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBzZXRSdW5JZCA9IChydW5JZDogc3RyaW5nKSA9PiB7XG4gIF9ydW5JZCA9IHJ1bklkO1xufTtcblxubGV0IF9jeXByZXNzVmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IHNldEN5cHJlc3NWZXJzaW9uID0gKGN5cHJlc3NWZXJzaW9uOiBzdHJpbmcpID0+IHtcbiAgX2N5cHJlc3NWZXJzaW9uID0gY3lwcmVzc1ZlcnNpb247XG59O1xuXG5sZXQgX2N1cnJlbnRzVmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IHNldEN1cnJlbnRzVmVyc2lvbiA9ICh2OiBzdHJpbmcpID0+IHtcbiAgX2N1cnJlbnRzVmVyc2lvbiA9IHY7XG59O1xuXG5mdW5jdGlvbiBvblJldHJ5KFxuICByZXRyeUNvdW50OiBudW1iZXIsXG4gIGVycjogQXhpb3NFcnJvcjx7IG1lc3NhZ2U6IHN0cmluZzsgZXJyb3JzPzogc3RyaW5nW10gfT4sXG4gIGNvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4pIHtcbiAgd2FybihcbiAgICBcIk5ldHdvcmsgcmVxdWVzdCAnJXMnIGZhaWxlZDogJyVzJy4gTmV4dCBhdHRlbXB0IGlzIGluICVzICglZC8lZCkuXCIsXG4gICAgYCR7Y29uZmlnLm1ldGhvZH0gJHtjb25maWcudXJsfWAsXG4gICAgZXJyLm1lc3NhZ2UsXG4gICAgcHJldHR5TWlsbGlzZWNvbmRzKGdldERlbGF5KHJldHJ5Q291bnQpKSxcbiAgICByZXRyeUNvdW50LFxuICAgIE1BWF9SRVRSSUVTXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBtYWtlUmVxdWVzdCA9IGFzeW5jIDxUID0gYW55LCBEID0gYW55PihcbiAgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWc8RD5cbikgPT4ge1xuICByZXR1cm4gKGF3YWl0IGdldENsaWVudCgpKTxELCBBeGlvc1Jlc3BvbnNlPFQ+Pihjb25maWcpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZGVidWcoXCJuZXR3b3JrIHJlc3BvbnNlOiAlb1wiLCBfLm9taXQocmVzLCBcInJlcXVlc3RcIiwgXCJjb25maWdcIikpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIG1heWJlUHJpbnRFcnJvcnMoZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9KTtcbn07XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuXG5pbXBvcnQgeyBQLCBtYXRjaCB9IGZyb20gXCJ0cy1wYXR0ZXJuXCI7XG5pbXBvcnQgeyBEZXRlY3RlZEJyb3dzZXIsIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgYm9vdEN5cHJlc3MgfSBmcm9tIFwiLi4vYm9vdHN0cmFwXCI7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0Q29uZmlnRmlsZVBhdGggfSBmcm9tIFwiLi9wYXRoXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjb25maWdcIik7XG5cbmV4cG9ydCB0eXBlIEUyRUNvbmZpZyA9IHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q29uZmlnID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbn07XG5leHBvcnQgdHlwZSBDdXJyZW50c0NvbmZpZyA9IHtcbiAgcHJvamVjdElkPzogc3RyaW5nO1xuICByZWNvcmRLZXk/OiBzdHJpbmc7XG4gIGNsb3VkU2VydmljZVVybDogc3RyaW5nO1xuICBlMmU6IEUyRUNvbmZpZztcbiAgY29tcG9uZW50OiBDb21wb25lbnRDb25maWc7XG4gIG5ldHdvcmtIZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn07XG5cbmxldCBfY29uZmlnOiBDdXJyZW50c0NvbmZpZyB8IG51bGwgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0Q29uZmlnOiBDdXJyZW50c0NvbmZpZyA9IHtcbiAgZTJlOiB7XG4gICAgYmF0Y2hTaXplOiAzLFxuICB9LFxuICBjb21wb25lbnQ6IHtcbiAgICBiYXRjaFNpemU6IDUsXG4gIH0sXG4gIGNsb3VkU2VydmljZVVybDogXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiLFxuICBuZXR3b3JrSGVhZGVyczogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRzQ29uZmlnKFxuICBwcm9qZWN0Um9vdD86IHN0cmluZyxcbiAgZXhwbGljaXRDb25maWdGaWxlUGF0aD86IHN0cmluZ1xuKTogUHJvbWlzZTxDdXJyZW50c0NvbmZpZz4ge1xuICBpZiAoX2NvbmZpZykge1xuICAgIHJldHVybiBfY29uZmlnO1xuICB9XG5cbiAgY29uc3QgY29uZmlnRmlsZVBhdGggPSBnZXRDb25maWdGaWxlUGF0aChwcm9qZWN0Um9vdCwgZXhwbGljaXRDb25maWdGaWxlUGF0aCk7XG4gIC8vIHRyeSBsb2FkaW5nIHBvc3NpYmxlIGNvbmZpZyBmaWxlc1xuICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnID0gbWF0Y2goYXdhaXQgbG9hZENvbmZpZ0ZpbGUoZmlsZXBhdGgpKVxuICAgICAgLndpdGgoeyBkZWZhdWx0OiBQLm5vdChQLm51bGxpc2gpIH0sIChjKSA9PiBjLmRlZmF1bHQpXG4gICAgICAud2l0aChQLm5vdChQLm51bGxpc2gpLCAoYykgPT4gYylcbiAgICAgIC5vdGhlcndpc2UoKCkgPT4gbnVsbCk7XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBkZWJ1ZyhcImxvYWRlZCBjdXJyZW50cyBjb25maWcgZnJvbSAnJXMnXFxuJU9cIiwgZmlsZXBhdGgsIGNvbmZpZyk7XG4gICAgICBpbmZvKFwiVXNpbmcgY29uZmlnIGZpbGU6ICclcydcIiwgZmlsZXBhdGgpO1xuICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBfY29uZmlnO1xuICAgIH1cbiAgfVxuXG4gIHdhcm4oXG4gICAgXCJGYWlsZWQgdG8gbG9hZCBjb25maWcgZmlsZSwgZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbmZpZy4gQXR0ZW1wdGVkIGxvY2F0aW9uczogJXNcIixcbiAgICBjb25maWdGaWxlUGF0aFxuICApO1xuICBfY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgcmV0dXJuIF9jb25maWc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRDb25maWdGaWxlKGZpbGVwYXRoOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBkZWJ1ZyhcImxvYWRpbmcgY3VycmVudHMgY29uZmlnIGZpbGUgZnJvbSAnJXMnXCIsIGZpbGVwYXRoKTtcbiAgICByZXR1cm4gYXdhaXQgaW1wb3J0KGZpbGVwYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKFwiZmFpbGVkIGxvYWRpbmcgY29uZmlnIGZpbGUgZnJvbTogJXNcIiwgZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTWVyZ2VkQ29uZmlnID0gQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBnZXRNZXJnZWRDb25maWc+PjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNZXJnZWRDb25maWcocGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMpIHtcbiAgZGVidWcoXCJyZXNvbHZpbmcgY3lwcmVzcyBjb25maWdcIik7XG4gIGNvbnN0IGN5cHJlc3NSZXNvbHZlZENvbmZpZzpcbiAgICB8IChDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9ucyAmIHtcbiAgICAgICAgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgICAgICAgcmF3SnNvbjogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIGJyb3dzZXJzOiBEZXRlY3RlZEJyb3dzZXJbXTtcbiAgICAgIH0pXG4gICAgfCB1bmRlZmluZWQgPSBhd2FpdCBib290Q3lwcmVzcyhwYXJhbXMpO1xuXG4gIGRlYnVnKFwiY3lwcmVzcyByZXNvbHZlZENvbmZpZzogJU9cIiwgY3lwcmVzc1Jlc29sdmVkQ29uZmlnKTtcblxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHJhd0UyRVBhdHRlcm4gPSBjeXByZXNzUmVzb2x2ZWRDb25maWcucmF3SnNvbj8uZTJlPy5zcGVjUGF0dGVybjtcbiAgbGV0IGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAocGFyYW1zLnRlc3RpbmdUeXBlID09PSBcImNvbXBvbmVudFwiICYmIHJhd0UyRVBhdHRlcm4pIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4gPSByYXdFMkVQYXR0ZXJuO1xuICB9XG5cbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9lZDA2NjhlMjRjMmVlNjc1M2JiZDI1YWU0NjdjZTk0YWU1ODU3NzQxL3BhY2thZ2VzL2NvbmZpZy9zcmMvb3B0aW9ucy50cyNMNDU3XG4gIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvZGV2ZWxvcC9wYWNrYWdlcy9jb25maWcvc3JjL3Byb2plY3QvdXRpbHMudHMjTDQxMlxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcHJvamVjdFJvb3Q6IGN5cHJlc3NSZXNvbHZlZENvbmZpZz8ucHJvamVjdFJvb3QgfHwgcHJvY2Vzcy5jd2QoKSxcbiAgICBwcm9qZWN0SWQ6IHBhcmFtcy5wcm9qZWN0SWQsXG4gICAgc3BlY1BhdHRlcm46IGN5cHJlc3NSZXNvbHZlZENvbmZpZz8uc3BlY1BhdHRlcm4gfHwgXCIqKi8qLipcIixcbiAgICBleGNsdWRlU3BlY1BhdHRlcm46XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnJlc29sdmVkLmV4Y2x1ZGVTcGVjUGF0dGVybi52YWx1ZSA/PyBbXSxcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgICByZXNvbHZlZDogY3lwcmVzc1Jlc29sdmVkQ29uZmlnLFxuICAgIGV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nOiBwYXJhbXMuZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcsXG4gIH07XG4gIGRlYnVnKFwibWVyZ2VkIGNvbmZpZzogJU9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJpbXBvcnQgeyBnZXRCaW5QYXRoIH0gZnJvbSBcImN5MlwiO1xuaW1wb3J0IHsgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBleGVjYSwgeyBFeGVjYUVycm9yIH0gZnJvbSBcImV4ZWNhXCI7XG5pbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBjcmVhdGVUZW1wRmlsZSB9IGZyb20gXCIuLi9mc1wiO1xuaW1wb3J0IHsgYm9sZCwgaW5mbyB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vcmVxdWlyZVwiO1xuaW1wb3J0IHsgZ2V0Qm9vdHN0cmFwQXJncyB9IGZyb20gXCIuL3NlcmlhbGl6ZXJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJvb3RcIik7XG5cbmV4cG9ydCBjb25zdCBib290Q3lwcmVzcyA9IGFzeW5jIChwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycykgPT4ge1xuICBkZWJ1ZyhcImJvb3RpbmcgY3lwcmVzcy4uLlwiKTtcbiAgY29uc3QgdGVtcEZpbGVQYXRoID0gYXdhaXQgY3JlYXRlVGVtcEZpbGUoKTtcblxuICBjb25zdCBjeXByZXNzQmluID0gYXdhaXQgZ2V0QmluUGF0aChyZXF1aXJlLnJlc29sdmUoXCJjeXByZXNzXCIpKTtcbiAgZGVidWcoXCJjeXByZXNzIGV4ZWN1dGFibGUgbG9jYXRpb246ICVzXCIsIGN5cHJlc3NCaW4pO1xuXG4gIC8vIGl0IGlzIGltcG9ydGFudCB0byBwYXNzIHRoZSBzYW1lIGFyZ3MgaW4gb3JkZXIgdG8gZ2V0IHRoZSBzYW1lIGNvbmZpZyBhcyBmb3IgdGhlIGFjdHVhbCBydW5cbiAgY29uc3QgYXJncyA9IGdldEJvb3RzdHJhcEFyZ3MoeyB0ZW1wRmlsZVBhdGgsIHBhcmFtcyB9KTtcbiAgZGVidWcoXCJib290aW5nIGN5cHJlc3Mgd2l0aCBhcmdzOiAlb1wiLCBhcmdzKTtcbiAgY29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlY0N5cHJlc3MoY3lwcmVzc0JpbiwgYXJncyk7XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKHRlbXBGaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHJlc29sdmUgY3lwcmVzcyBjb25maWd1cmF0aW9uIGZyb20gJHt0ZW1wRmlsZVBhdGh9LiBQbGVhc2UgcmVwb3J0IHRoZSBpc3N1ZS5gXG4gICAgKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGYgPSBmcy5yZWFkRmlsZVN5bmModGVtcEZpbGVQYXRoLCBcInV0Zi04XCIpO1xuICAgIGlmICghZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXMgY3lwcmVzcy1jbG91ZC9wbHVnaW4gaW5zdGFsbGVkP1wiKTtcbiAgICB9XG4gICAgZGVidWcoXCJjeXByZXNzIGNvbmZpZyAnJXMnOiAnJXMnXCIsIHRlbXBGaWxlUGF0aCwgZik7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlYnVnKFwicmVhZCBjb25maWcgdGVtcCBmaWxlIGZhaWxlZDogJW9cIiwgZXJyKTtcbiAgICBpbmZvKGJvbGQoXCJDeXByZXNzIHN0ZG91dDpcXG5cIiksIHN0ZG91dCk7XG4gICAgaW5mbyhib2xkKFwiQ3lwcmVzcyBzdGRlcnI6XFxuXCIpLCBzdGRlcnIpO1xuXG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgY3lwcmVzcyBjb25maWd1cmF0aW9uXG4tIG1ha2Ugc3VyZSB0aGF0ICdjeXByZXNzLWNsb3VkL3BsdWdpbicgaXMgaW5zdGFsbGVkXG4tIHJlcG9ydCB0aGUgaXNzdWUgdG9nZXRoZXIgd2l0aCBjeXByZXNzIHN0ZG91dCBhbmQgc3RkZXJyXG5gKTtcbiAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gZXhlY0N5cHJlc3MoY3lwcmVzc0Jpbjogc3RyaW5nLCBhcmdzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICBsZXQgc3Rkb3V0ID0gXCJcIjtcbiAgbGV0IHN0ZGVyciA9IFwiXCI7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlY2EoY3lwcmVzc0JpbiwgW1wicnVuXCIsIC4uLmFyZ3NdLCB7XG4gICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgIC8vIHByZXZlbnQgd2FybmluZ3MgYWJvdXQgcmVjb3JkaW5nIG1vZGVcbiAgICAgICAgQ1lQUkVTU19SRUNPUkRfS0VZOiB1bmRlZmluZWQsXG4gICAgICAgIENZUFJFU1NfUFJPSkVDVF9JRDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoXCJleGVjIGN5cHJlc3MgZmFpbGVkIChjZXJ0YWluIGZhaWx1cmVzIGFyZSBleHBlY3RlZCk6ICVvXCIsIGVycik7XG4gICAgc3Rkb3V0ID0gKGVyciBhcyBFeGVjYUVycm9yKS5zdGRvdXQ7XG4gICAgc3RkZXJyID0gKGVyciBhcyBFeGVjYUVycm9yKS5zdGRlcnI7XG4gIH1cbiAgcmV0dXJuIHsgc3Rkb3V0LCBzdGRlcnIgfTtcbn1cbiIsICJleHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZmlsZSB9IGZyb20gXCJ0bXAtcHJvbWlzZVwiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVtcEZpbGUgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgcGF0aCB9ID0gYXdhaXQgZmlsZSgpO1xuICByZXR1cm4gcGF0aDtcbn07XG4iLCAiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcblxuY29uc3QgbG9nID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gY29uc29sZS5sb2codXRpbC5mb3JtYXQoLi4uYXJncykpO1xuXG5leHBvcnQgY29uc3QgaW5mbyA9IGxvZztcbmV4cG9ydCBjb25zdCBmb3JtYXQgPSB1dGlsLmZvcm1hdDtcblxuZXhwb3J0IGNvbnN0IHdpdGhFcnJvciA9IChtc2c6IHN0cmluZykgPT5cbiAgY2hhbGsuYmdSZWQud2hpdGUoXCIgRVJST1IgXCIpICsgXCIgXCIgKyBtc2c7XG5leHBvcnQgY29uc3Qgd2l0aFdhcm5pbmcgPSAobXNnOiBzdHJpbmcpID0+XG4gIGNoYWxrLmJnWWVsbG93LmJsYWNrKFwiIFdBUk5JTkcgXCIpICsgXCIgXCIgKyBtc2c7XG5cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKHdpdGhXYXJuaW5nKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBzdWNjZXNzID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgbG9nKGNoYWxrLmdyZWVuKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSk7XG5cbmV4cG9ydCBjb25zdCBlcnJvciA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyh3aXRoRXJyb3IodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCJcXG5cIik7XG5cbnR5cGUgQ29sb3IgPSBcInJlZFwiIHwgXCJncmVlblwiIHwgXCJ5ZWxsb3dcIiB8IFwiYmx1ZVwiIHwgXCJtYWdlbnRhXCIgfCBcImN5YW5cIiB8IFwid2hpdGVcIjtcbmV4cG9ydCBjb25zdCB0aXRsZSA9IChjb2xvcjogQ29sb3IsIC4uLmFyZ3M6IHVua25vd25bXSkgPT5cbiAgaW5mbyhcIlxcblwiICsgXCIgIFwiICsgY2hhbGtbY29sb3JdLmJvbGQodXRpbC5mb3JtYXQoLi4uYXJncykpICsgXCIgIFwiICsgXCJcXG5cIik7XG5cbmV4cG9ydCBjb25zdCBkaXZpZGVyID0gKCkgPT5cbiAgY29uc29sZS5sb2coXCJcXG5cIiArIGNoYWxrLmdyYXkoQXJyYXkoMTAwKS5maWxsKFwiPVwiKS5qb2luKFwiXCIpKSArIFwiXFxuXCIpO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VyID0gKG46IG51bWJlciA9IDApID0+XG4gIGNvbnNvbGUubG9nKEFycmF5KG4pLmZpbGwoXCJcIikuam9pbihcIlxcblwiKSk7XG5cbmV4cG9ydCBjb25zdCBjeWFuID0gY2hhbGsuY3lhbjtcbmV4cG9ydCBjb25zdCBibHVlID0gY2hhbGsuYmx1ZUJyaWdodDtcbmV4cG9ydCBjb25zdCByZWQgPSBjaGFsay5yZWQ7XG5leHBvcnQgY29uc3QgZ3JlZW4gPSBjaGFsay5ncmVlbkJyaWdodDtcbmV4cG9ydCBjb25zdCBncmF5ID0gY2hhbGsuZ3JheTtcbmV4cG9ydCBjb25zdCB3aGl0ZSA9IGNoYWxrLndoaXRlO1xuZXhwb3J0IGNvbnN0IG1hZ2VudGEgPSBjaGFsay5tYWdlbnRhO1xuZXhwb3J0IGNvbnN0IGJvbGQgPSBjaGFsay5ib2xkO1xuZXhwb3J0IGNvbnN0IHllbGxvdyA9IGNoYWxrLnllbGxvdztcbmV4cG9ydCBjb25zdCBkaW0gPSBjaGFsay5kaW07XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBDeXByZXNzUnVuUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpib290XCIpO1xuXG5jb25zdCBnZXREdW1teVNwZWMgPSBjdXN0b21BbHBoYWJldChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsIDEwKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvb3RzdHJhcEFyZ3Moe1xuICBwYXJhbXMsXG4gIHRlbXBGaWxlUGF0aCxcbn06IHtcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnM7XG4gIHRlbXBGaWxlUGF0aDogc3RyaW5nO1xufSkge1xuICByZXR1cm4gXy5jaGFpbihnZXRDeXByZXNzQ0xJUGFyYW1zKHBhcmFtcykpXG4gICAgLnRocnUoKG9wdHMpID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgLy8gbWVyZ2UgdGhlIGVudiB3aXRoIHRoZSBjdXJyZW50cyBzcGVjaWZpYyBlbnYgdmFyaWFibGVzXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4uKG9wdHMuZW52ID8/IHt9KSxcbiAgICAgICAgY3VycmVudHNfdGVtcF9maWxlOiB0ZW1wRmlsZVBhdGgsXG4gICAgICAgIGN1cnJlbnRzX2RlYnVnX2VuYWJsZWQ6IHByb2Nlc3MuZW52LkRFQlVHPy5pbmNsdWRlcyhcImN1cnJlbnRzOlwiKVxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pKVxuICAgIC50YXAoKG9wdHMpID0+IHtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBib290c3RyYXAgcGFyYW1zOiAlb1wiLCBvcHRzKTtcbiAgICB9KVxuICAgIC50aHJ1KHNlcmlhbGl6ZU9wdGlvbnMpXG4gICAgLnRhcCgob3B0cykgPT4ge1xuICAgICAgZGVidWcoXCJjeXByZXNzIGJvb3RzdHJhcCBzZXJpYWxpemVkIHBhcmFtczogJW9cIiwgb3B0cyk7XG4gICAgfSlcbiAgICAudGhydSgoYXJncykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgXCItLXNwZWNcIixcbiAgICAgICAgZ2V0RHVtbXlTcGVjKCksXG4gICAgICAgIHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiA/IFwiLS1jb21wb25lbnRcIiA6IFwiLS1lMmVcIixcbiAgICAgIF07XG4gICAgfSlcbiAgICAudmFsdWUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBDdXJyZW50cyBvcHRpb25zIHRvIEN5cHJlc3MgQ0xJIHBhcmFtcy5cbiAqIEN5cHJlc3MgQ0xJIG9wdGlvbnMgYXJlIGRpZmZlcmVudCBmcm9tIEN5cHJlc3MgbW9kdWxlIEFQSSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgQ3VycmVudHMgcGFyYW1cbiAqIEByZXR1cm5zIEN5cHJlc3MgQ0xJIHBhcmFtc1xuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvZ3VpZGVzL2NvbW1hbmQtbGluZSNjeXByZXNzLXJ1blxuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9hcGkvbW9kdWxlLWFwaVxuICovXG5mdW5jdGlvbiBnZXRDeXByZXNzQ0xJUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3lwcmVzc1J1blBhcmFtZXRlcnMge1xuICBjb25zdCByZXN1bHQgPSBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKHBhcmFtcyk7XG4gIGNvbnN0IHRlc3RpbmdUeXBlID1cbiAgICByZXN1bHQudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCJcbiAgICAgID8ge1xuICAgICAgICAgIGNvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgOiB7fTtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLm9taXQocmVzdWx0LCBcInRlc3RpbmdUeXBlXCIpLFxuICAgIC4uLnRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmxhdE1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgX2tleSA9IGRhc2hlZChrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyBbYC0tJHtfa2V5fWBdIDogW2AtLSR7X2tleX1gLCBmYWxzZV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW2AtLSR7X2tleX1gLCBzZXJpYWxpemVDb21wbGV4UGFyYW0odmFsdWUpXTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIFtgLS0ke19rZXl9YCwgdmFsdWUudG9TdHJpbmcoKV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVDb21wbGV4UGFyYW0ocGFyYW06IHt9KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbSk7XG59XG5cbmNvbnN0IGRhc2hlZCA9ICh2OiBzdHJpbmcpID0+IHYucmVwbGFjZSgvW0EtWl0vZywgKG0pID0+IFwiLVwiICsgbS50b0xvd2VyQ2FzZSgpKTtcbiIsICJpbXBvcnQgaXNBYnNvbHV0ZSBmcm9tIFwiaXMtYWJzb2x1dGVcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RmlsZW5hbWVzID0gW1xuICBcImN1cnJlbnRzLmNvbmZpZy5qc1wiLFxuICBcImN1cnJlbnRzLmNvbmZpZy5janNcIixcbiAgXCJjdXJyZW50cy5jb25maWcubWpzXCIsXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZ0ZpbGVQYXRoKFxuICBwcm9qZWN0Um9vdDogc3RyaW5nIHwgbnVsbCA9IG51bGwsXG4gIGV4cGxpY2l0Q29uZmlnRmlsZVBhdGg/OiBzdHJpbmdcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgcHJlZml4ID0gcHJvamVjdFJvb3QgPz8gcHJvY2Vzcy5jd2QoKTtcbiAgaWYgKFxuICAgIF8uaXNTdHJpbmcoZXhwbGljaXRDb25maWdGaWxlUGF0aCkgJiZcbiAgICBpc0Fic29sdXRlKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpXG4gICkge1xuICAgIHJldHVybiBbZXhwbGljaXRDb25maWdGaWxlUGF0aF07XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoZXhwbGljaXRDb25maWdGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gW25vcm1hbGl6ZVBhdGgocHJlZml4LCBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKV07XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lcy5tYXAoKHApID0+IG5vcm1hbGl6ZVBhdGgocHJlZml4LCBwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHByZWZpeDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBmaWxlOi8vJHtwYXRoLnJlc29sdmUocHJlZml4LCBmaWxlbmFtZSl9YDtcbn1cbiIsICJpbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSdW5QYXJhbWV0ZXJzLFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRzQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6dmFsaWRhdGVQYXJhbXNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQ3VycmVudHNQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBQcm9taXNlPEN1cnJlbnRzUnVuUGFyYW1ldGVycz4ge1xuICBjb25zdCBjb25maWdGcm9tRmlsZSA9IGF3YWl0IGdldEN1cnJlbnRzQ29uZmlnKFxuICAgIHBhcmFtcy5wcm9qZWN0LFxuICAgIHBhcmFtcy5jbG91ZENvbmZpZ0ZpbGVcbiAgKTtcblxuICBkZWJ1ZyhcInJlc29sdmluZyBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG4gIGRlYnVnKFwicmVzb2x2aW5nIGN1cnJlbnRzIGNvbmZpZyBmaWxlOiAlb1wiLCBjb25maWdGcm9tRmlsZSk7XG4gIGNvbnN0IGNsb3VkU2VydmljZVVybCA9XG4gICAgcGFyYW1zLmNsb3VkU2VydmljZVVybCA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX0FQSV9VUkwgPz9cbiAgICBjb25maWdGcm9tRmlsZS5jbG91ZFNlcnZpY2VVcmw7XG5cbiAgY29uc3QgcmVjb3JkS2V5ID1cbiAgICBwYXJhbXMucmVjb3JkS2V5ID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUkVDT1JEX0tFWSA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLnJlY29yZEtleTtcblxuICBjb25zdCBwcm9qZWN0SWQgPVxuICAgIHBhcmFtcy5wcm9qZWN0SWQgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19QUk9KRUNUX0lEID8/XG4gICAgY29uZmlnRnJvbUZpbGUucHJvamVjdElkO1xuXG4gIGNvbnN0IHRlc3RpbmdUeXBlID0gcGFyYW1zLnRlc3RpbmdUeXBlID8/IFwiZTJlXCI7XG5cbiAgY29uc3QgYmF0Y2hTaXplID1cbiAgICB0ZXN0aW5nVHlwZSA9PT0gXCJlMmVcIlxuICAgICAgPyBjb25maWdGcm9tRmlsZS5lMmUuYmF0Y2hTaXplXG4gICAgICA6IGNvbmZpZ0Zyb21GaWxlLmNvbXBvbmVudC5iYXRjaFNpemU7XG5cbiAgLy8gYmF0Y2hTaXplIGFuZCBjbG91ZFNlcnZpY2VVcmwgZGVmYXVsdHMgYXJlIGluIGdldEN1cnJlbnRzQ29uZmlnKClcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgY2xvdWRTZXJ2aWNlVXJsLFxuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgYmF0Y2hTaXplLFxuICAgIHRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgcHJvamVjdElkRXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcHJvamVjdElkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLSBwcm92aWRlIGl0IGFzIGEgXCJwcm9qZWN0SWRcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19QUk9KRUNUX0lEIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcInByb2plY3RJZFwiIGluIFwiY3VycmVudHMuY29uZmlnLntjfWpzXCIgZmlsZWA7XG5cbmV4cG9ydCBjb25zdCBjbG91ZFNlcnZpY2VVcmxFcnJvciA9IGBDYW5ub3QgcmVzb2x2ZSBjbG91ZCBzZXJ2aWNlIFVSTC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi0gcHJvdmlkZSBpdCBhcyBhIFwiY2xvdWRTZXJ2aWNlVXJsXCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfQVBJX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJjbG91ZFNlcnZpY2VVcmxcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy57Y31qc1wiIGZpbGVgO1xuXG5leHBvcnQgY29uc3QgY2xvdWRTZXJ2aWNlSW52YWxpZFVybEVycm9yID0gYEludmFsaWQgY2xvdWQgc2VydmljZSBVUkwgcHJvdmlkZWRgO1xuXG5leHBvcnQgY29uc3QgcmVjb3JkS2V5RXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcmVjb3JkIGtleS4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblxuLSBwYXNzIGl0IGFzIGEgQ0xJIGZsYWcgJy1rLCAtLWtleSA8cmVjb3JkLWtleT4nXG4tIHByb3ZpZGUgaXQgYXMgYSBcInJlY29yZEtleVwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX1JFQ09SRF9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwicmVjb3JkS2V5XCIgaW4gXCJjdXJyZW50cy5jb25maWcue2N9anNcIiBmaWxlXG5gO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMoXG4gIF9wYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM+IHtcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgcmVzb2x2ZUN1cnJlbnRzUGFyYW1zKF9wYXJhbXMpO1xuXG4gIGRlYnVnKFwidmFsaWRhdGluZyBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG4gIGlmICghcGFyYW1zLmNsb3VkU2VydmljZVVybCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoY2xvdWRTZXJ2aWNlVXJsRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnByb2plY3RJZCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocHJvamVjdElkRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnJlY29yZEtleSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocmVjb3JkS2V5RXJyb3IpO1xuICB9XG5cbiAgdmFsaWRhdGVVUkwocGFyYW1zLmNsb3VkU2VydmljZVVybCk7XG5cbiAgY29uc3QgcmVxdWlyZWRQYXJhbWV0ZXJzOiBBcnJheTxrZXlvZiBDdXJyZW50c1J1blBhcmFtZXRlcnM+ID0gW1xuICAgIFwidGVzdGluZ1R5cGVcIixcbiAgICBcImJhdGNoU2l6ZVwiLFxuICAgIFwicHJvamVjdElkXCIsXG4gIF07XG4gIHJlcXVpcmVkUGFyYW1ldGVycy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcmFtc1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBlcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgXCIlc1wiJywga2V5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcGFyYW1zLnRhZyA9IHBhcnNlVGFncyhwYXJhbXMudGFnKTtcbiAgcGFyYW1zLmF1dG9DYW5jZWxBZnRlckZhaWx1cmVzID0gZ2V0QXV0b0NhbmNlbFZhbHVlKFxuICAgIHBhcmFtcy5hdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1xuICApO1xuXG4gIGRlYnVnKFwidmFsaWRhdGVkIGN1cnJlbnRzIHBhcmFtczogJW9cIiwgcGFyYW1zKTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjYXN0IGFmdGVyIGZpbmRpbmcgYSB3YXkgdG8gcHJvcGVybHkgcmVzb2x2ZSBwYXJhbXMgdHlwZSBhZnRlciB2YWxpZGF0aW9uc1xuICByZXR1cm4gcGFyYW1zIGFzIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b0NhbmNlbFZhbHVlKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgZmFsc2UgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICBgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXM6IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgXCJmYWxzZVwiLiBHb3Q6IFwiJHt2YWx1ZX1cImBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2ZmbGluZShwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycykge1xuICByZXR1cm4gcGFyYW1zLnJlY29yZCA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFncyh0YWdTdHJpbmc6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInRhZ1wiXSk6IHN0cmluZ1tdIHtcbiAgaWYgKCF0YWdTdHJpbmcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFnU3RyaW5nKSkge1xuICAgIHJldHVybiB0YWdTdHJpbmcuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG4gIHJldHVybiB0YWdTdHJpbmdcbiAgICAuc3BsaXQoXCIsXCIpXG4gICAgLm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVVJMKHVybDogc3RyaW5nKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2Nsb3VkU2VydmljZUludmFsaWRVcmxFcnJvcn06IFwiJHt1cmx9XCJgKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBDeXByZXNzIG9wdGlvbnMgd2l0aG91dCBpdGVtcyB0aGF0IGFmZmVjdCByZWNvcmRpbmcgbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN5cHJlc3NSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLnBpY2tCeShcbiAgICAgIF8ub21pdChwYXJhbXMsIFtcbiAgICAgICAgXCJjbG91ZERlYnVnXCIsXG4gICAgICAgIFwiY2xvdWRDb25maWdGaWxlXCIsXG4gICAgICAgIFwiYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXNcIixcbiAgICAgICAgXCJjbG91ZFNlcnZpY2VVcmxcIixcbiAgICAgICAgXCJiYXRjaFNpemVcIixcbiAgICAgICAgXCJwcm9qZWN0SWRcIixcbiAgICAgICAgXCJrZXlcIixcbiAgICAgICAgXCJyZWNvcmRLZXlcIixcbiAgICAgICAgXCJyZWNvcmRcIixcbiAgICAgICAgXCJncm91cFwiLFxuICAgICAgICBcInBhcmFsbGVsXCIsXG4gICAgICAgIFwidGFnXCIsXG4gICAgICAgIFwiY2lCdWlsZElkXCIsXG4gICAgICAgIFwic3BlY1wiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJoZWFkbGVzc1wiLFxuICAgICAgICBcImV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nXCIsXG4gICAgICBdKSxcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIHJlY29yZDogZmFsc2UsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3VycmVudHNSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgc3BlYzogcHJvY2Vzc1NwZWNQYXJhbShwYXJhbXMuc3BlYyksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTcGVjUGFyYW0oXG4gIHNwZWM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInNwZWNcIl1cbik6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihzcGVjLm1hcCgoaSkgPT4gaS5zcGxpdChcIixcIikpKTtcbiAgfVxuXG4gIHJldHVybiBzcGVjLnNwbGl0KFwiLFwiKTtcbn1cbiIsICJpbXBvcnQgeyBBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBzcGFjZXIsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVByaW50RXJyb3JzKFxuICBlcnI6IEF4aW9zRXJyb3I8eyBtZXNzYWdlOiBzdHJpbmc7IGVycm9ycz86IHN0cmluZ1tdIH0+XG4pIHtcbiAgaWYgKCFlcnIucmVzcG9uc2U/LmRhdGEgfHwgIWVyci5yZXNwb25zZT8uc3RhdHVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBtZXNzYWdlLCBlcnJvcnMgfSA9IGVyci5yZXNwb25zZS5kYXRhO1xuXG4gIHN3aXRjaCAoZXJyLnJlc3BvbnNlLnN0YXR1cykge1xuICAgIGNhc2UgNDAxOlxuICAgICAgd2FybihcIlJlY2VpdmVkIDQwMSBVbmF1dGhvcml6ZWRcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQyMjpcbiAgICAgIHNwYWNlcigxKTtcbiAgICAgIHdhcm4oLi4uZm9ybWF0R2VuZXJpY0Vycm9yKG1lc3NhZ2UsIGVycm9ycykpO1xuICAgICAgc3BhY2VyKDEpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRHZW5lcmljRXJyb3IoXG4gIG1lc3NhZ2U/OiBzdHJpbmcsXG4gIGVycm9ycz86IHN0cmluZ1tdXG4pOiBzdHJpbmdbXSB7XG4gIGlmICghXy5pc1N0cmluZyhtZXNzYWdlKSkge1xuICAgIHJldHVybiBbXCJVbmV4cGVjdGVkIGVycm9yIGZyb20gdGhlIGNsb3VkIHNlcnZpY2VcIl07XG4gIH1cblxuICBpZiAoZXJyb3JzPy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW21lc3NhZ2UgYXMgc3RyaW5nXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIG1lc3NhZ2UgYXMgc3RyaW5nLFxuICAgIGBcbiR7KGVycm9ycyA/PyBbXSkubWFwKChlKSA9PiBgICAtICR7ZX1gKS5qb2luKFwiXFxuXCIpfVxuYCxcbiAgXTtcbn1cbiIsICJpbXBvcnQgeyByZXF1aXJlIH0gZnJvbSBcIi4uL2xpYi9yZXF1aXJlXCI7XG5pbXBvcnQgXCIuL3N0ZG91dFwiO1xuaW1wb3J0IFwiLi93c1wiO1xuXG5jb25zdCBjeXByZXNzUGtnID0gcmVxdWlyZShcImN5cHJlc3MvcGFja2FnZS5qc29uXCIpO1xuY29uc3QgcGtnID0gcmVxdWlyZShcImN5cHJlc3MtY2xvdWQvcGFja2FnZS5qc29uXCIpO1xuXG5pbXBvcnQgeyBpbml0Q2FwdHVyZSB9IGZyb20gXCIuL2NhcHR1cmVcIjtcbmltcG9ydCB7IHNldEN1cnJlbnRzVmVyc2lvbiwgc2V0Q3lwcmVzc1ZlcnNpb24gfSBmcm9tIFwiLi9odHRwQ2xpZW50XCI7XG5cbmluaXRDYXB0dXJlKCk7XG5zZXRDeXByZXNzVmVyc2lvbihjeXByZXNzUGtnLnZlcnNpb24pO1xuc2V0Q3VycmVudHNWZXJzaW9uKHBrZy52ZXJzaW9uKTtcbiIsICJpbXBvcnQgXCIuL2luaXRcIjtcblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHBsdXIgZnJvbSBcInBsdXJcIjtcbmltcG9ydCB7IGdldExlZ2FsTm90aWNlIH0gZnJvbSBcIi4uL2xlZ2FsXCI7XG5pbXBvcnQgeyBDdXJyZW50c1J1blBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZVJ1biB9IGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0IHsgY3V0SW5pdGlhbE91dHB1dCwgZ2V0Q2FwdHVyZWRPdXRwdXQgfSBmcm9tIFwiLi9jYXB0dXJlXCI7XG5pbXBvcnQgeyBnZXRDSSB9IGZyb20gXCIuL2NpUHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGdldE1lcmdlZENvbmZpZyxcbiAgaXNPZmZsaW5lLFxuICBwcmVwcm9jZXNzUGFyYW1zLFxuICB2YWxpZGF0ZVBhcmFtcyxcbn0gZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgeyBnZXRDb3ZlcmFnZUZpbGVQYXRoIH0gZnJvbSBcIi4vY292ZXJhZ2VcIjtcbmltcG9ydCB7IHJ1bkJhcmVDeXByZXNzIH0gZnJvbSBcIi4vY3lwcmVzc1wiO1xuaW1wb3J0IHsgYWN0aXZhdGVEZWJ1ZyB9IGZyb20gXCIuL2RlYnVnXCI7XG5pbXBvcnQgeyBpc0N1cnJlbnRzIH0gZnJvbSBcIi4vZW52XCI7XG5pbXBvcnQgeyBnZXRHaXRJbmZvIH0gZnJvbSBcIi4vZ2l0XCI7XG5pbXBvcnQgeyBzZXRBUElCYXNlVXJsLCBzZXRSdW5JZCB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcbmltcG9ydCB7IGJvbGQsIGRpbSwgZGl2aWRlciwgaW5mbywgc3BhY2VyLCB0aXRsZSwgd2FybiwgeWVsbG93IH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybSB9IGZyb20gXCIuL3BsYXRmb3JtXCI7XG5pbXBvcnQgeyBwdWJzdWIgfSBmcm9tIFwiLi9wdWJzdWJcIjtcbmltcG9ydCB7IHN1bW1hcml6ZVRlc3RSZXN1bHRzLCBzdW1tYXJ5VGFibGUgfSBmcm9tIFwiLi9yZXN1bHRzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVSZXBvcnRUYXNrU3BlYyxcbiAgcmVwb3J0VGFza3MsXG4gIHJ1blRpbGxEb25lT3JDYW5jZWxsZWQsXG59IGZyb20gXCIuL3J1bm5lclwiO1xuaW1wb3J0IHsgc2h1dGRvd24gfSBmcm9tIFwiLi9zaHV0ZG93blwiO1xuaW1wb3J0IHsgZ2V0U3BlY0ZpbGVzIH0gZnJvbSBcIi4vc3BlY01hdGNoZXJcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XG5pbXBvcnQgeyBzdGFydFdTUyB9IGZyb20gXCIuL3dzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpydW5cIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW4ocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSB7fSkge1xuICBjb25zdCBleGVjdXRpb25TdGF0ZSA9IG5ldyBFeGVjdXRpb25TdGF0ZSgpO1xuICBjb25zdCBjb25maWdTdGF0ZSA9IG5ldyBDb25maWdTdGF0ZSgpO1xuICBhY3RpdmF0ZURlYnVnKHBhcmFtcy5jbG91ZERlYnVnKTtcbiAgZGVidWcoXCJydW4gcGFyYW1zICVvXCIsIHBhcmFtcyk7XG4gIHBhcmFtcyA9IHByZXByb2Nlc3NQYXJhbXMocGFyYW1zKTtcbiAgZGVidWcoXCJwYXJhbXMgYWZ0ZXIgcHJlcHJvY2VzcyAlb1wiLCBwYXJhbXMpO1xuXG4gIGlmIChpc09mZmxpbmUocGFyYW1zKSkge1xuICAgIGluZm8oYFNraXBwaW5nIGNsb3VkIG9yY2hlc3RyYXRpb24gYmVjYXVzZSAtLXJlY29yZCBpcyBzZXQgdG8gZmFsc2VgKTtcbiAgICByZXR1cm4gcnVuQmFyZUN5cHJlc3MocGFyYW1zKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlZFBhcmFtcyA9IGF3YWl0IHZhbGlkYXRlUGFyYW1zKHBhcmFtcyk7XG4gIHNldEFQSUJhc2VVcmwodmFsaWRhdGVkUGFyYW1zLmNsb3VkU2VydmljZVVybCk7XG5cbiAgaWYgKCFpc0N1cnJlbnRzKCkpIHtcbiAgICBjb25zb2xlLmxvZyhnZXRMZWdhbE5vdGljZSgpKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICByZWNvcmRLZXksXG4gICAgcHJvamVjdElkLFxuICAgIGdyb3VwLFxuICAgIHBhcmFsbGVsLFxuICAgIGNpQnVpbGRJZCxcbiAgICB0YWcsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgYmF0Y2hTaXplLFxuICAgIGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzLFxuICAgIGV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nLFxuICB9ID0gdmFsaWRhdGVkUGFyYW1zO1xuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGdldE1lcmdlZENvbmZpZyh2YWxpZGF0ZWRQYXJhbXMpO1xuICBjb25maWdTdGF0ZS5zZXRDb25maWcoY29uZmlnPy5yZXNvbHZlZCk7XG5cbiAgY29uc3QgeyBzcGVjcywgc3BlY1BhdHRlcm4gfSA9IGF3YWl0IGdldFNwZWNGaWxlcyh7XG4gICAgY29uZmlnLFxuICAgIHBhcmFtczogdmFsaWRhdGVkUGFyYW1zLFxuICB9KTtcblxuICBpZiAoc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBnZXRQbGF0Zm9ybSh7XG4gICAgY29uZmlnLFxuICAgIGJyb3dzZXI6IHZhbGlkYXRlZFBhcmFtcy5icm93c2VyLFxuICB9KTtcblxuICBpbmZvKFwiRGlzY292ZXJlZCAlZCBzcGVjIGZpbGVzXCIsIHNwZWNzLmxlbmd0aCk7XG4gIGluZm8oXG4gICAgYFRhZ3M6ICR7dGFnLmxlbmd0aCA+IDAgPyB0YWcuam9pbihcIixcIikgOiBmYWxzZX07IEdyb3VwOiAke1xuICAgICAgZ3JvdXAgPz8gZmFsc2VcbiAgICB9OyBQYXJhbGxlbDogJHtwYXJhbGxlbCA/PyBmYWxzZX07IEJhdGNoIFNpemU6ICR7YmF0Y2hTaXplfWBcbiAgKTtcbiAgaW5mbyhcIkNvbm5lY3RpbmcgdG8gY2xvdWQgb3JjaGVzdHJhdGlvbiBzZXJ2aWNlLi4uXCIpO1xuXG4gIGNvbnN0IHJ1biA9IGF3YWl0IGNyZWF0ZVJ1bih7XG4gICAgY2k6IGdldENJKGNpQnVpbGRJZCksXG4gICAgc3BlY3M6IHNwZWNzLm1hcCgoc3BlYykgPT4gc3BlYy5yZWxhdGl2ZSksXG4gICAgY29tbWl0OiBhd2FpdCBnZXRHaXRJbmZvKGNvbmZpZy5wcm9qZWN0Um9vdCksXG4gICAgZ3JvdXAsXG4gICAgcGxhdGZvcm0sXG4gICAgcGFyYWxsZWw6IHBhcmFsbGVsID8/IGZhbHNlLFxuICAgIGNpQnVpbGRJZCxcbiAgICBwcm9qZWN0SWQsXG4gICAgcmVjb3JkS2V5LFxuICAgIHNwZWNQYXR0ZXJuOiBbc3BlY1BhdHRlcm5dLmZsYXQoMiksXG4gICAgdGFnczogdGFnLFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIGJhdGNoU2l6ZSxcbiAgICBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlcyxcbiAgICBjb3ZlcmFnZUVuYWJsZWQ6IGV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nLFxuICB9KTtcblxuICBzZXRSdW5JZChydW4ucnVuSWQpO1xuICBpbmZvKFwiXHVEODNDXHVERkE1IFJ1biBVUkw6XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuICBjdXRJbml0aWFsT3V0cHV0KCk7XG5cbiAgYXdhaXQgc3RhcnRXU1MoKTtcbiAgbGlzdGVuVG9TcGVjRXZlbnRzKFxuICAgIGNvbmZpZ1N0YXRlLFxuICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgIGNvbmZpZy5leHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZ1xuICApO1xuXG4gIGF3YWl0IHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgY29uZmlnU3RhdGUsXG4gICAge1xuICAgICAgcnVuSWQ6IHJ1bi5ydW5JZCxcbiAgICAgIGdyb3VwSWQ6IHJ1bi5ncm91cElkLFxuICAgICAgbWFjaGluZUlkOiBydW4ubWFjaGluZUlkLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBzcGVjcyxcbiAgICB9LFxuICAgIHZhbGlkYXRlZFBhcmFtc1xuICApO1xuXG4gIGRpdmlkZXIoKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVwb3J0VGFza3MpO1xuICBjb25zdCBfc3VtbWFyeSA9IHN1bW1hcml6ZVRlc3RSZXN1bHRzKFxuICAgIGV4ZWN1dGlvblN0YXRlLmdldFJlc3VsdHMoY29uZmlnU3RhdGUpLFxuICAgIGNvbmZpZ1xuICApO1xuXG4gIHRpdGxlKFwid2hpdGVcIiwgXCJDbG91ZCBSdW4gRmluaXNoZWRcIik7XG4gIGNvbnNvbGUubG9nKHN1bW1hcnlUYWJsZShfc3VtbWFyeSkpO1xuXG4gIHByaW50V2FybmluZ3MoZXhlY3V0aW9uU3RhdGUpO1xuXG4gIGluZm8oXCJcXG5cdUQ4M0NcdURGQzEgUmVjb3JkZWQgUnVuOlwiLCBib2xkKHJ1bi5ydW5VcmwpKTtcblxuICBhd2FpdCBzaHV0ZG93bigpO1xuXG4gIHNwYWNlcigpO1xuICBpZiAoX3N1bW1hcnkuc3RhdHVzID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uX3N1bW1hcnksXG4gICAgICBydW5Vcmw6IHJ1bi5ydW5VcmwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfc3VtbWFyeTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9TcGVjRXZlbnRzKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmc/OiBib29sZWFuXG4pIHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlnU3RhdGUuZ2V0Q29uZmlnKCk7XG4gIHB1YnN1Yi5vbihcImJlZm9yZTpzcGVjXCIsIGFzeW5jICh7IHNwZWMgfTogeyBzcGVjOiBDeXByZXNzLlNwZWMgfSkgPT4ge1xuICAgIGRlYnVnKFwiYmVmb3JlOnNwZWMgJW9cIiwgc3BlYyk7XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0U3BlY0JlZm9yZShzcGVjLnJlbGF0aXZlKTtcbiAgfSk7XG5cbiAgcHVic3ViLm9uKFxuICAgIFwiYWZ0ZXI6c3BlY1wiLFxuICAgIGFzeW5jICh7IHNwZWMsIHJlc3VsdHMgfTogeyBzcGVjOiBDeXByZXNzLlNwZWM7IHJlc3VsdHM6IGFueSB9KSA9PiB7XG4gICAgICBkZWJ1ZyhcImFmdGVyOnNwZWMgJW8gJW9cIiwgc3BlYywgcmVzdWx0cyk7XG4gICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQWZ0ZXIoc3BlYy5yZWxhdGl2ZSwgcmVzdWx0cyk7XG4gICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjT3V0cHV0KHNwZWMucmVsYXRpdmUsIGdldENhcHR1cmVkT3V0cHV0KCkpO1xuXG4gICAgICBpZiAoZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBlcnJvciB9ID0gYXdhaXQgZ2V0Q292ZXJhZ2VGaWxlUGF0aChcbiAgICAgICAgICBjb25maWc/LmVudj8uY292ZXJhZ2VGaWxlXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQ292ZXJhZ2Uoc3BlYy5yZWxhdGl2ZSwgcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgIGBDb3VsZCBub3QgcHJvY2VzcyBjb3ZlcmFnZSBmaWxlIFwiJHtwYXRofVwiXFxuJHtkaW0oZXJyb3IpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjcmVhdGVSZXBvcnRUYXNrU3BlYyhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIHNwZWMucmVsYXRpdmUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5ncyhleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUpIHtcbiAgY29uc3Qgd2FybmluZ3MgPSBBcnJheS5mcm9tKGV4ZWN1dGlvblN0YXRlLmdldFdhcm5pbmdzKCkpO1xuICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgIHdhcm4oXG4gICAgICBgJHt3YXJuaW5ncy5sZW5ndGh9ICR7cGx1cihcbiAgICAgICAgXCJXYXJuaW5nXCIsXG4gICAgICAgIHdhcm5pbmdzLmxlbmd0aFxuICAgICAgKX0gZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBleGVjdXRpb246XFxuJHt3YXJuaW5nc1xuICAgICAgICAubWFwKCh3LCBpKSA9PiBgXFxuJHt5ZWxsb3coYFske2kgKyAxfS8ke3dhcm5pbmdzLmxlbmd0aH1dYCl9ICR7d31gKVxuICAgICAgICAuam9pbihcIlxcblwiKX1gXG4gICAgKTtcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRMZWdhbE5vdGljZSgpIHtcbiAgcmV0dXJuIGBcbkNvcHlyaWdodCAoQykgJHtuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCl9IEN1cnJlbnRzIFNvZnR3YXJlIEluYyBodHRwczovL2N1cnJlbnRzLmRldlxuVGhpcyBpcyBmcmVlIHNvZnR3YXJlLCBhbmQgeW91IGFyZSB3ZWxjb21lIHRvIHJlZGlzdHJpYnV0ZSBpdCB1bmRlciBjZXJ0YWluXG5jb25kaXRpb25zLiBUaGlzIHByb2dyYW0gY29tZXMgd2l0aCBubyB3YXJyYW50eS4gUGFydHMgb2YgdGhpcyBwcm9ncmFtIGFyZSBNSVRcbmxpY2Vuc2VkLiBSZWZlciB0byB0aGUgbGljZW5zZSBmb3IgZGV0YWlsc1xuaHR0cHM6Ly9naXRodWIuY29tL2N1cnJlbnRzLWRldi9jeXByZXNzLWNsb3VkL2Jsb2IvbWFpbi9MSUNFTlNFLm1kXG5gO1xufVxuIiwgImltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IG1hZ2VudGEgfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmltcG9ydCB7IGluZm8sIHNwYWNlciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IENsb3VkV2FybmluZyB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludFdhcm5pbmdzKHdhcm5pbmdzOiBDbG91ZFdhcm5pbmdbXSkge1xuICB3YXJuKFwiTm90aWNlIGZyb20gY2xvdWQgc2VydmljZTpcIik7XG4gIHdhcm5pbmdzLm1hcCgodykgPT4ge1xuICAgIHNwYWNlcigxKTtcbiAgICBpbmZvKG1hZ2VudGEuYm9sZCh3Lm1lc3NhZ2UpKTtcbiAgICBPYmplY3QuZW50cmllcyhfLm9taXQodywgXCJtZXNzYWdlXCIpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaW5mbyhcIi0gJXM6ICVzXCIsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHNwYWNlcigxKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgbWFrZVJlcXVlc3QgfSBmcm9tIFwiLi4vaHR0cENsaWVudFwiO1xuaW1wb3J0IHtcbiAgQ3JlYXRlSW5zdGFuY2VDeVBheWxvYWQsXG4gIENyZWF0ZUluc3RhbmNlUGF5bG9hZCxcbiAgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSxcbiAgQ3JlYXRlSW5zdGFuY2VzUmVzcG9uc2UsXG4gIENyZWF0ZVJ1blBheWxvYWQsXG4gIENyZWF0ZVJ1blJlc3BvbnNlLFxuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzTWVyZ2VkUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2UsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBwcmludFdhcm5pbmdzIH0gZnJvbSBcIi4vd2FybmluZ3NcIjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJ1biA9IGFzeW5jIChwYXlsb2FkOiBDcmVhdGVSdW5QYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3Q8Q3JlYXRlUnVuUmVzcG9uc2UsIENyZWF0ZVJ1blBheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvcnVuc1wiLFxuICAgIGRhdGE6IHBheWxvYWQsXG4gIH0pO1xuXG4gIGlmICgocmVzcG9uc2UuZGF0YS53YXJuaW5ncz8ubGVuZ3RoID8/IDApID4gMCkge1xuICAgIHByaW50V2FybmluZ3MocmVzcG9uc2UuZGF0YS53YXJuaW5ncyk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IGFzeW5jICh7XG4gIHJ1bklkLFxuICBncm91cElkLFxuICBtYWNoaW5lSWQsXG4gIHBsYXRmb3JtLFxufTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3Q8XG4gICAgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSxcbiAgICBDcmVhdGVJbnN0YW5jZVBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBydW5zLyR7cnVuSWR9L2luc3RhbmNlc2AsXG4gICAgZGF0YToge1xuICAgICAgcnVuSWQsXG4gICAgICBncm91cElkLFxuICAgICAgbWFjaGluZUlkLFxuICAgICAgcGxhdGZvcm0sXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyA9IGFzeW5jIChkYXRhOiBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCkgPT4ge1xuICBjb25zdCByZXNwb25lID0gYXdhaXQgbWFrZVJlcXVlc3Q8XG4gICAgQ3JlYXRlSW5zdGFuY2VzUmVzcG9uc2UsXG4gICAgQ3JlYXRlSW5zdGFuY2VDeVBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBydW5zLyR7ZGF0YS5ydW5JZH0vY3kvaW5zdGFuY2VzYCxcbiAgICBkYXRhLFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEluc3RhbmNlVGVzdHMgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWRcbikgPT5cbiAgbWFrZVJlcXVlc3Q8e30sIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS90ZXN0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVJbnN0YW5jZVJlc3VsdHMgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDxVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSwgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vcmVzdWx0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCByZXBvcnRJbnN0YW5jZVJlc3VsdHNNZXJnZWQgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogVXBkYXRlSW5zdGFuY2VSZXN1bHRzTWVyZ2VkUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDxcbiAgICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSxcbiAgICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkXG4gID4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vY3kvcmVzdWx0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVJbnN0YW5jZVN0ZG91dCA9IChpbnN0YW5jZUlkOiBzdHJpbmcsIHN0ZG91dDogc3RyaW5nKSA9PlxuICBtYWtlUmVxdWVzdDxhbnksIHsgc3Rkb3V0OiBzdHJpbmcgfT4oe1xuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9zdGRvdXRgLFxuICAgIGRhdGE6IHtcbiAgICAgIHN0ZG91dCxcbiAgICB9LFxuICB9KTtcbiIsICIvKiEgQHByZXNlcnZlXG5cbiMjIyBNSVRcblxuUGFydHMgb2YgdGhpcyBjb2RlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzIGFuZCBpcyBzdWJqZWN0IHRvIE1JVCBsaWNlbnNlLlxuXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMjIgQ3lwcmVzcy5pb1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuXG5pbXBvcnQgZGVidWdGbiBmcm9tIFwiZGVidWdcIjtcblxuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBHaGFFdmVudERhdGEgfSBmcm9tIFwiLi9naXRcIjtcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZuKFwiY3VycmVudHM6Y2lcIik7XG5cbmNvbnN0IGpvaW4gPSAoY2hhcjogc3RyaW5nLCAuLi5waWVjZXM6IChzdHJpbmcgfCB1bmRlZmluZWQpW10pID0+IHtcbiAgcmV0dXJuIF8uY2hhaW4ocGllY2VzKS5jb21wYWN0KCkuam9pbihjaGFyKS52YWx1ZSgpO1xufTtcblxuY29uc3QgdG9DYW1lbE9iamVjdCA9IChvYmo6IGFueSwga2V5OiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIF8uc2V0KG9iaiwgXy5jYW1lbENhc2Uoa2V5KSwgcHJvY2Vzcy5lbnZba2V5XSk7XG59O1xuXG5jb25zdCBleHRyYWN0ID0gKGVudktleXM6IHN0cmluZ1tdKSA9PiB7XG4gIHJldHVybiBfLnRyYW5zZm9ybShlbnZLZXlzLCB0b0NhbWVsT2JqZWN0LCB7fSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIFRlYW1Gb3VuZGF0aW9uIHNlcnZlci5cbiAqIEBzZWUgaHR0cHM6Ly90ZWNobmV0Lm1pY3Jvc29mdC5jb20vZW4tdXMvaGg4NTA0NDgodj12cy45MilcbiAqL1xuY29uc3QgaXNUZWFtRm91bmRhdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LlRGX0JVSUxEICYmIHByb2Nlc3MuZW52LlRGX0JVSUxEX0JVSUxETlVNQkVSO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBBenVyZSBDSSBwaXBlbGluZS5cbiAqIFNlZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gdGhlIGlzc3VlICMzNjU3XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvaXNzdWVzLzM2NTdcbiAqL1xuY29uc3QgaXNBenVyZUNpID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuVEZfQlVJTEQgJiYgcHJvY2Vzcy5lbnYuQVpVUkVfSFRUUF9VU0VSX0FHRU5UO1xufTtcblxuY29uc3QgaXNBV1NDb2RlQnVpbGQgPSAoKSA9PiB7XG4gIHJldHVybiBfLnNvbWUocHJvY2Vzcy5lbnYsICh2YWwsIGtleSkgPT4ge1xuICAgIHJldHVybiAvXkNPREVCVUlMRF8vLnRlc3Qoa2V5KTtcbiAgfSk7XG59O1xuXG5jb25zdCBpc0JhbWJvbyA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LmJhbWJvb19idWlsZE51bWJlcjtcbn07XG5cbmNvbnN0IGlzQ29kZXNoaXBCYXNpYyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FICYmXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSA9PT0gXCJjb2Rlc2hpcFwiICYmXG4gICAgcHJvY2Vzcy5lbnYuQ09ERVNISVBcbiAgKTtcbn07XG5cbmNvbnN0IGlzQ29kZXNoaXBQcm8gPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSAmJlxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgPT09IFwiY29kZXNoaXBcIiAmJlxuICAgICFwcm9jZXNzLmVudi5DT0RFU0hJUFxuICApO1xufTtcblxuY29uc3QgaXNDb25jb3Vyc2UgPSAoKSA9PiB7XG4gIHJldHVybiBfLnNvbWUocHJvY2Vzcy5lbnYsICh2YWwsIGtleSkgPT4ge1xuICAgIHJldHVybiAvXkNPTkNPVVJTRV8vLnRlc3Qoa2V5KTtcbiAgfSk7XG59O1xuXG5jb25zdCBpc0dpdGxhYiA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5HSVRMQUJfQ0kgfHxcbiAgICAocHJvY2Vzcy5lbnYuQ0lfU0VSVkVSX05BTUUgJiYgL15HaXRMYWIvLnRlc3QocHJvY2Vzcy5lbnYuQ0lfU0VSVkVSX05BTUUpKVxuICApO1xufTtcblxuY29uc3QgaXNHb29nbGVDbG91ZCA9ICgpID0+IHtcbiAgLy8gc2V0IGF1dG9tYXRpY2FsbHkgZm9yIHRoZSBOb2RlLmpzIDYsIE5vZGUuanMgOCBydW50aW1lcyAobm90IGluIE5vZGUgMTApXG4gIC8vIFRPRE86IG1heSBhbHNvIHBvdGVudGlhbGx5IGhhdmUgWF9HT09HTEVfKiBlbnYgdmFyIHNldFxuICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciNlbnZpcm9ubWVudF92YXJpYWJsZXNfc2V0X2F1dG9tYXRpY2FsbHlcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5HQ1BfUFJPSkVDVCB8fFxuICAgIHByb2Nlc3MuZW52LkdDTE9VRF9QUk9KRUNUIHx8XG4gICAgcHJvY2Vzcy5lbnYuR09PR0xFX0NMT1VEX1BST0pFQ1RcbiAgKTtcbn07XG5cbmNvbnN0IGlzSmVua2lucyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX1VSTCB8fFxuICAgIHByb2Nlc3MuZW52LkpFTktJTlNfSE9NRSB8fFxuICAgIHByb2Nlc3MuZW52LkpFTktJTlNfVkVSU0lPTiB8fFxuICAgIHByb2Nlc3MuZW52LkhVRFNPTl9VUkwgfHxcbiAgICBwcm9jZXNzLmVudi5IVURTT05fSE9NRVxuICApO1xufTtcblxuY29uc3QgaXNXZXJja2VyID0gKCkgPT4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuV0VSQ0tFUiB8fCBwcm9jZXNzLmVudi5XRVJDS0VSX01BSU5fUElQRUxJTkVfU1RBUlRFRDtcbn07XG5cbi8qKlxuICogV2UgZGV0ZWN0IENJIHByb3ZpZGVycyBieSBkZXRlY3RpbmcgYW4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIHVuaXF1ZSB0byB0aGUgcHJvdmlkZXIsIG9yIGJ5IGNhbGxpbmcgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZVxuICogZm9yIHRoYXQgcHJvdmlkZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIEFwcFZleW9yIENJIGhhcyBlbnZpcm9ubWVudCB0aGVcbiAqIHZhcmlhYmxlIFwiQVBQVkVZT1JcIiBzZXQgZHVyaW5nIHJ1blxuICovXG5jb25zdCBDSV9QUk9WSURFUlMgPSB7XG4gIGFwcHZleW9yOiBcIkFQUFZFWU9SXCIsXG4gIGF6dXJlOiBpc0F6dXJlQ2ksXG4gIGF3c0NvZGVCdWlsZDogaXNBV1NDb2RlQnVpbGQsXG4gIGJhbWJvbzogaXNCYW1ib28sXG4gIGJpdGJ1Y2tldDogXCJCSVRCVUNLRVRfQlVJTERfTlVNQkVSXCIsXG4gIGJ1aWxka2l0ZTogXCJCVUlMREtJVEVcIixcbiAgY2lyY2xlOiBcIkNJUkNMRUNJXCIsXG4gIGNvZGVzaGlwQmFzaWM6IGlzQ29kZXNoaXBCYXNpYyxcbiAgY29kZXNoaXBQcm86IGlzQ29kZXNoaXBQcm8sXG4gIGNvbmNvdXJzZTogaXNDb25jb3Vyc2UsXG4gIGNvZGVGcmVzaDogXCJDRl9CVUlMRF9JRFwiLFxuICBkcm9uZTogXCJEUk9ORVwiLFxuICBnaXRodWJBY3Rpb25zOiBcIkdJVEhVQl9BQ1RJT05TXCIsXG4gIGdpdGxhYjogaXNHaXRsYWIsXG4gIGdvQ0Q6IFwiR09fSk9CX05BTUVcIixcbiAgZ29vZ2xlQ2xvdWQ6IGlzR29vZ2xlQ2xvdWQsXG4gIGplbmtpbnM6IGlzSmVua2lucyxcbiAgc2VtYXBob3JlOiBcIlNFTUFQSE9SRVwiLFxuICBzaGlwcGFibGU6IFwiU0hJUFBBQkxFXCIsXG4gIHRlYW1jaXR5OiBcIlRFQU1DSVRZX1ZFUlNJT05cIixcbiAgdGVhbWZvdW5kYXRpb246IGlzVGVhbUZvdW5kYXRpb24sXG4gIHRyYXZpczogXCJUUkFWSVNcIixcbiAgd2VyY2tlcjogaXNXZXJja2VyLFxuICBuZXRsaWZ5OiBcIk5FVExJRllcIixcbiAgbGF5ZXJjaTogXCJMQVlFUkNJXCIsXG59O1xuXG5mdW5jdGlvbiBfZGV0ZWN0UHJvdmlkZXJOYW1lKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHsgZW52IH0gPSBwcm9jZXNzO1xuICAvLyByZXR1cm4gdGhlIGtleSBvZiB0aGUgZmlyc3QgcHJvdmlkZXJcbiAgLy8gd2hpY2ggaXMgdHJ1dGh5XG5cbiAgcmV0dXJuIF8uZmluZEtleShDSV9QUk9WSURFUlMsICh2YWx1ZSkgPT4ge1xuICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGVudlt2YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFRPRE86IGRvbid0IGZvciBhYm91dCBidWlsZE51bWJlciFcbi8vIGxvb2sgYXQgdGhlIG9sZCBjb21taXQgdGhhdCB3YXMgcmVtb3ZlZCB0byBzZWUgaG93IHdlIGRpZCBpdFxuY29uc3QgX3Byb3ZpZGVyQ2lQYXJhbXMgPSAoKTogUHJvdmlkZXJDaVBhcmFtc1JlcyA9PiB7XG4gIHJldHVybiB7XG4gICAgYXBwdmV5b3I6IGV4dHJhY3QoW1xuICAgICAgXCJBUFBWRVlPUl9KT0JfSURcIixcbiAgICAgIFwiQVBQVkVZT1JfQUNDT1VOVF9OQU1FXCIsXG4gICAgICBcIkFQUFZFWU9SX1BST0pFQ1RfU0xVR1wiLFxuICAgICAgXCJBUFBWRVlPUl9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQVBQVkVZT1JfQlVJTERfVkVSU0lPTlwiLFxuICAgICAgXCJBUFBWRVlPUl9QVUxMX1JFUVVFU1RfTlVNQkVSXCIsXG4gICAgICBcIkFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIXCIsXG4gICAgXSksXG4gICAgYXp1cmU6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9CVUlMRElEXCIsXG4gICAgICBcIkJVSUxEX0JVSUxETlVNQkVSXCIsXG4gICAgICBcIkJVSUxEX0NPTlRBSU5FUklEXCIsXG4gICAgICBcIkJVSUxEX1JFUE9TSVRPUllfVVJJXCIsXG4gICAgXSksXG4gICAgYXdzQ29kZUJ1aWxkOiBleHRyYWN0KFtcbiAgICAgIFwiQ09ERUJVSUxEX0JVSUxEX0lEXCIsXG4gICAgICBcIkNPREVCVUlMRF9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQ09ERUJVSUxEX1JFU09MVkVEX1NPVVJDRV9WRVJTSU9OXCIsXG4gICAgICBcIkNPREVCVUlMRF9TT1VSQ0VfUkVQT19VUkxcIixcbiAgICAgIFwiQ09ERUJVSUxEX1NPVVJDRV9WRVJTSU9OXCIsXG4gICAgXSksXG4gICAgYmFtYm9vOiBleHRyYWN0KFtcbiAgICAgIFwiYmFtYm9vX2J1aWxkTnVtYmVyXCIsXG4gICAgICBcImJhbWJvb19idWlsZFJlc3VsdHNVcmxcIixcbiAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JlcG9zaXRvcnlVcmxcIixcbiAgICAgIFwiYmFtYm9vX2J1aWxkS2V5XCIsXG4gICAgXSksXG4gICAgYml0YnVja2V0OiBleHRyYWN0KFtcbiAgICAgIFwiQklUQlVDS0VUX1JFUE9fU0xVR1wiLFxuICAgICAgXCJCSVRCVUNLRVRfUkVQT19PV05FUlwiLFxuICAgICAgXCJCSVRCVUNLRVRfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QQVJBTExFTF9TVEVQXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9TVEVQX1JVTl9OVU1CRVJcIixcbiAgICAgIC8vIHRoZSBQUiB2YXJpYWJsZXMgYXJlIG9ubHkgc2V0IG9uIHB1bGwgcmVxdWVzdCBidWlsZHNcbiAgICAgIFwiQklUQlVDS0VUX1BSX0lEXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9ERVNUSU5BVElPTl9CUkFOQ0hcIixcbiAgICAgIFwiQklUQlVDS0VUX1BSX0RFU1RJTkFUSU9OX0NPTU1JVFwiLFxuICAgIF0pLFxuICAgIGJ1aWxka2l0ZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxES0lURV9SRVBPXCIsXG4gICAgICBcIkJVSUxES0lURV9TT1VSQ0VcIixcbiAgICAgIFwiQlVJTERLSVRFX0pPQl9JRFwiLFxuICAgICAgXCJCVUlMREtJVEVfQlVJTERfSURcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX1VSTFwiLFxuICAgICAgXCJCVUlMREtJVEVfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RcIixcbiAgICAgIFwiQlVJTERLSVRFX1BVTExfUkVRVUVTVF9SRVBPXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RfQkFTRV9CUkFOQ0hcIixcbiAgICBdKSxcbiAgICBjaXJjbGU6IGV4dHJhY3QoW1xuICAgICAgXCJDSVJDTEVfSk9CXCIsXG4gICAgICBcIkNJUkNMRV9CVUlMRF9OVU1cIixcbiAgICAgIFwiQ0lSQ0xFX0JVSUxEX1VSTFwiLFxuICAgICAgXCJDSVJDTEVfUFJfTlVNQkVSXCIsXG4gICAgICBcIkNJUkNMRV9QUl9SRVBPTkFNRVwiLFxuICAgICAgXCJDSVJDTEVfUFJfVVNFUk5BTUVcIixcbiAgICAgIFwiQ0lSQ0xFX0NPTVBBUkVfVVJMXCIsXG4gICAgICBcIkNJUkNMRV9XT1JLRkxPV19JRFwiLFxuICAgICAgXCJDSVJDTEVfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkNJUkNMRV9SRVBPU0lUT1JZX1VSTFwiLFxuICAgICAgXCJDSV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICBjb2Rlc2hpcEJhc2ljOiBleHRyYWN0KFtcbiAgICAgIFwiQ0lfQlVJTERfSURcIixcbiAgICAgIFwiQ0lfUkVQT19OQU1FXCIsXG4gICAgICBcIkNJX0JVSUxEX1VSTFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX0lEXCIsXG4gICAgICBcIkNJX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJDSV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICAvLyBDb2Rlc2hpcFBybyBwcm92aWRlcyB2ZXJ5IGZldyBDSSB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2RvY3VtZW50YXRpb24uY29kZXNoaXAuY29tL3Byby9idWlsZHMtYW5kLWNvbmZpZ3VyYXRpb24vZW52aXJvbm1lbnQtdmFyaWFibGVzL1xuICAgIGNvZGVzaGlwUHJvOiBleHRyYWN0KFtcIkNJX0JVSUxEX0lEXCIsIFwiQ0lfUkVQT19OQU1FXCIsIFwiQ0lfUFJPSkVDVF9JRFwiXSksXG4gICAgLy8gaHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL2ltcGxlbWVudGluZy1yZXNvdXJjZS10eXBlcy5odG1sI3Jlc291cmNlLW1ldGFkYXRhXG4gICAgY29uY291cnNlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiQlVJTERfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9KT0JfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkJVSUxEX1RFQU1fTkFNRVwiLFxuICAgICAgXCJBVENfRVhURVJOQUxfVVJMXCIsXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9jb2RlZnJlc2guaW8vZG9jcy9kb2NzL2NvZGVmcmVzaC15YW1sL3ZhcmlhYmxlcy9cbiAgICBjb2RlRnJlc2g6IGV4dHJhY3QoW1xuICAgICAgXCJDRl9CVUlMRF9JRFwiLFxuICAgICAgXCJDRl9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0ZfQ1VSUkVOVF9BVFRFTVBUXCIsXG4gICAgICBcIkNGX1NURVBfTkFNRVwiLFxuICAgICAgXCJDRl9QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkNGX1BJUEVMSU5FX1RSSUdHRVJfSURcIixcbiAgICAgIC8vIHZhcmlhYmxlcyBhZGRlZCBmb3IgcHVsbCByZXF1ZXN0c1xuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfSURcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX0lTX0ZPUktcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX05VTUJFUlwiLFxuICAgICAgXCJDRl9QVUxMX1JFUVVFU1RfVEFSR0VUXCIsXG4gICAgXSksXG4gICAgZHJvbmU6IGV4dHJhY3QoW1xuICAgICAgXCJEUk9ORV9KT0JfTlVNQkVSXCIsXG4gICAgICBcIkRST05FX0JVSUxEX0xJTktcIixcbiAgICAgIFwiRFJPTkVfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkRST05FX1BVTExfUkVRVUVTVFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vaGVscC5naXRodWIuY29tL2VuL2FjdGlvbnMvYXV0b21hdGluZy15b3VyLXdvcmtmbG93LXdpdGgtZ2l0aHViLWFjdGlvbnMvdXNpbmctZW52aXJvbm1lbnQtdmFyaWFibGVzI2RlZmF1bHQtZW52aXJvbm1lbnQtdmFyaWFibGVzXG4gICAgZ2l0aHViQWN0aW9uczogZXh0cmFjdChbXG4gICAgICBcIkdJVEhVQl9XT1JLRkxPV1wiLFxuICAgICAgXCJHSVRIVUJfQUNUSU9OXCIsXG4gICAgICBcIkdJVEhVQl9FVkVOVF9OQU1FXCIsXG4gICAgICBcIkdJVEhVQl9SVU5fSURcIixcbiAgICAgIFwiR0lUSFVCX1JVTl9BVFRFTVBUXCIsXG4gICAgICBcIkdJVEhVQl9SRVBPU0lUT1JZXCIsXG4gICAgXSksXG4gICAgLy8gc2VlIGh0dHBzOi8vZG9jcy5naXRsYWIuY29tL2VlL2NpL3ZhcmlhYmxlcy9cbiAgICBnaXRsYWI6IGV4dHJhY3QoW1xuICAgICAgLy8gcGlwZWxpbmUgaXMgY29tbW9uIGFtb25nIGFsbCBqb2JzXG4gICAgICBcIkNJX1BJUEVMSU5FX0lEXCIsXG4gICAgICBcIkNJX1BJUEVMSU5FX1VSTFwiLFxuICAgICAgLy8gaW5kaXZpZHVhbCBqb2JzXG4gICAgICBcIkNJX0JVSUxEX0lEXCIsIC8vIGJ1aWxkIGlkIGFuZCBqb2IgaWQgYXJlIGFsaWFzZXNcbiAgICAgIFwiQ0lfSk9CX0lEXCIsXG4gICAgICBcIkNJX0pPQl9VUkxcIixcbiAgICAgIFwiQ0lfSk9CX05BTUVcIixcbiAgICAgIC8vIG90aGVyIGluZm9ybWF0aW9uXG4gICAgICBcIkdJVExBQl9IT1NUXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfSURcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9VUkxcIixcbiAgICAgIFwiQ0lfUkVQT1NJVE9SWV9VUkxcIixcbiAgICAgIFwiQ0lfRU5WSVJPTk1FTlRfVVJMXCIsXG4gICAgICBcIkNJX0RFRkFVTFRfQlJBTkNIXCIsXG4gICAgICAvLyBmb3IgUFJzOiBodHRwczovL2dpdGxhYi5jb20vZ2l0bGFiLW9yZy9naXRsYWItY2UvaXNzdWVzLzIzOTAyXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9kb2NzLmdvY2Qub3JnL2N1cnJlbnQvZmFxL2Rldl91c2VfY3VycmVudF9yZXZpc2lvbl9pbl9idWlsZC5odG1sI3N0YW5kYXJkLWdvY2QtZW52aXJvbm1lbnQtdmFyaWFibGVzXG4gICAgZ29DRDogZXh0cmFjdChbXG4gICAgICBcIkdPX1NFUlZFUl9VUkxcIixcbiAgICAgIFwiR09fRU5WSVJPTk1FTlRfTkFNRVwiLFxuICAgICAgXCJHT19QSVBFTElORV9OQU1FXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX0NPVU5URVJcIixcbiAgICAgIFwiR09fUElQRUxJTkVfTEFCRUxcIixcbiAgICAgIFwiR09fU1RBR0VfTkFNRVwiLFxuICAgICAgXCJHT19TVEFHRV9DT1VOVEVSXCIsXG4gICAgICBcIkdPX0pPQl9OQU1FXCIsXG4gICAgICBcIkdPX1RSSUdHRVJfVVNFUlwiLFxuICAgICAgXCJHT19SRVZJU0lPTlwiLFxuICAgICAgXCJHT19UT19SRVZJU0lPTlwiLFxuICAgICAgXCJHT19GUk9NX1JFVklTSU9OXCIsXG4gICAgICBcIkdPX01BVEVSSUFMX0hBU19DSEFOR0VEXCIsXG4gICAgXSksXG4gICAgZ29vZ2xlQ2xvdWQ6IGV4dHJhY3QoW1xuICAgICAgLy8gaW5kaXZpZHVhbCBqb2JzXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIlBST0pFQ1RfSURcIixcbiAgICAgIC8vIG90aGVyIGluZm9ybWF0aW9uXG4gICAgICBcIlJFUE9fTkFNRVwiLFxuICAgICAgXCJCUkFOQ0hfTkFNRVwiLFxuICAgICAgXCJUQUdfTkFNRVwiLFxuICAgICAgXCJDT01NSVRfU0hBXCIsXG4gICAgICBcIlNIT1JUX1NIQVwiLFxuICAgICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Nsb3VkLWJ1aWxkL2RvY3MvYXBpL3JlZmVyZW5jZS9yZXN0L1NoYXJlZC5UeXBlcy9CdWlsZFxuICAgIF0pLFxuICAgIGplbmtpbnM6IGV4dHJhY3QoW1wiQlVJTERfSURcIiwgXCJCVUlMRF9VUkxcIiwgXCJCVUlMRF9OVU1CRVJcIiwgXCJnaHByYlB1bGxJZFwiXSksXG4gICAgLy8gaHR0cHM6Ly9zZW1hcGhvcmVjaS5jb20vZG9jcy9hdmFpbGFibGUtZW52aXJvbm1lbnQtdmFyaWFibGVzLmh0bWxcbiAgICAvLyBzb21lIGNvbWUgZnJvbSB2MSwgc29tZSBmcm9tIHYyIG9mIHNlbWFwaG9yZVxuICAgIHNlbWFwaG9yZTogZXh0cmFjdChbXG4gICAgICBcIlNFTUFQSE9SRV9CUkFOQ0hfSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJTRU1BUEhPUkVfQ1VSUkVOVF9KT0JcIixcbiAgICAgIFwiU0VNQVBIT1JFX0NVUlJFTlRfVEhSRUFEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9FWEVDVVRBQkxFX1VVSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9CUkFOQ0hcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9ESVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRUZcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRUZfVFlQRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1JFUE9fU0xVR1wiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgXCJTRU1BUEhPUkVfR0lUX1VSTFwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX0NPVU5UXCIsXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfSURcIiwgLy8gdjJcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9OQU1FXCIsXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfVVVJRFwiLCAvLyB2MVxuICAgICAgXCJTRU1BUEhPUkVfUElQRUxJTkVfSURcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BMQVRGT1JNXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX0RJUlwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9IQVNIX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX0lEXCIsIC8vIHYyXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX05BTUVcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfVVVJRFwiLCAvLyB2MVxuICAgICAgXCJTRU1BUEhPUkVfUkVQT19TTFVHXCIsXG4gICAgICBcIlNFTUFQSE9SRV9UUklHR0VSX1NPVVJDRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfV09SS0ZMT1dfSURcIixcbiAgICAgIFwiUFVMTF9SRVFVRVNUX05VTUJFUlwiLCAvLyBwdWxsIHJlcXVlc3RzIGZyb20gZm9ya3MgT05MWVxuICAgIF0pLFxuICAgIC8vIHNlZSBodHRwOi8vZG9jcy5zaGlwcGFibGUuY29tL2NpL2Vudi12YXJzL1xuICAgIHNoaXBwYWJsZTogZXh0cmFjdChbXG4gICAgICAvLyBidWlsZCB2YXJpYWJsZXNcbiAgICAgIFwiU0hJUFBBQkxFX0JVSUxEX0lEXCIsIC8vIFwiNWI5MzM1NGNhYmZhYmIwNzAwN2YwMWZkXCJcbiAgICAgIFwiU0hJUFBBQkxFX0JVSUxEX05VTUJFUlwiLCAvLyBcIjRcIlxuICAgICAgXCJTSElQUEFCTEVfQ09NTUlUX1JBTkdFXCIsIC8vIFwic2hhMS4uLnNoYTJcIlxuICAgICAgXCJTSElQUEFCTEVfQ09OVEFJTkVSX05BTUVcIiwgLy8gXCJjLmV4ZWMuY3lwcmVzcy1leGFtcGxlLWtpdGNoZW5zaW5rLjQuMVwiXG4gICAgICBcIlNISVBQQUJMRV9KT0JfSURcIiwgLy8gXCIxXCJcbiAgICAgIFwiU0hJUFBBQkxFX0pPQl9OVU1CRVJcIiwgLy8gXCIxXCJcbiAgICAgIFwiU0hJUFBBQkxFX1JFUE9fU0xVR1wiLCAvLyBcIjx1c2VybmFtZT4vPHJlcG8+XCJcbiAgICAgIC8vIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdGhhdCBTaGlwcGFibGUgcHJvdmlkZXNcbiAgICAgIFwiSVNfRk9SS1wiLCAvLyBcInRydWVcIlxuICAgICAgXCJJU19HSVRfVEFHXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJJU19QUkVSRUxFQVNFXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJJU19SRUxFQVNFXCIsIC8vIFwiZmFsc2VcIlxuICAgICAgXCJSRVBPU0lUT1JZX1VSTFwiLCAvLyBcImh0dHBzOi8vZ2l0aHViLmNvbS8uLi4uZ2l0XCJcbiAgICAgIFwiUkVQT19GVUxMX05BTUVcIiwgLy8gXCI8dXNlcm5hbWU+LzxyZXBvPlwiXG4gICAgICBcIlJFUE9fTkFNRVwiLCAvLyBcImN5cHJlc3MtZXhhbXBsZS1raXRjaGVuc2lua1wiXG4gICAgICBcIkJVSUxEX1VSTFwiLCAvLyBcImh0dHBzOi8vYXBwLnNoaXBwYWJsZS5jb20vZ2l0aHViLzx1c2VybmFtZT4vPHJlcG8+L3J1bnMvMVwiXG4gICAgICAvLyBQdWxsIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgIFwiQkFTRV9CUkFOQ0hcIiwgLy8gTmFtZSBvZiB0aGUgdGFyZ2V0IGJyYW5jaCBpbnRvIHdoaWNoIHRoZSBwdWxsIHJlcXVlc3QgY2hhbmdlcyB3aWxsIGJlIG1lcmdlZC5cbiAgICAgIFwiSEVBRF9CUkFOQ0hcIiwgLy8gVGhpcyBpcyBvbmx5IHNldCBmb3IgcHVsbCByZXF1ZXN0cyBhbmQgaXMgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCB0aGUgcHVsbCByZXF1ZXN0IHdhcyBvcGVuZWQgZnJvbS5cbiAgICAgIFwiSVNfUFVMTF9SRVFVRVNUXCIsIC8vIFwiZmFsc2VcIiBvciBcInRydWVcIlxuICAgICAgXCJQVUxMX1JFUVVFU1RcIiwgLy8gUHVsbCByZXF1ZXN0IG51bWJlciBpZiB0aGUgam9iIGlzIGEgcHVsbCByZXF1ZXN0LiBJZiBub3QsIHRoaXMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG4gICAgICBcIlBVTExfUkVRVUVTVF9CQVNFX0JSQU5DSFwiLCAvLyBOYW1lIG9mIHRoZSBicmFuY2ggdGhhdCB0aGUgcHVsbCByZXF1ZXN0IHdpbGwgYmUgbWVyZ2VkIGludG8uIEl0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyBCQVNFX0JSQU5DSC5cbiAgICAgIFwiUFVMTF9SRVFVRVNUX1JFUE9fRlVMTF9OQU1FXCIsIC8vIEZ1bGwgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSBmcm9tIHdoZXJlIHRoZSBwdWxsIHJlcXVlc3Qgb3JpZ2luYXRlZC5cbiAgICBdKSxcbiAgICB0ZWFtY2l0eTogbnVsbCxcbiAgICB0ZWFtZm91bmRhdGlvbjogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0JVSUxESURcIixcbiAgICAgIFwiQlVJTERfQlVJTEROVU1CRVJcIixcbiAgICAgIFwiQlVJTERfQ09OVEFJTkVSSURcIixcbiAgICBdKSxcbiAgICB0cmF2aXM6IGV4dHJhY3QoW1xuICAgICAgXCJUUkFWSVNfSk9CX0lEXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9JRFwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfV0VCX1VSTFwiLFxuICAgICAgXCJUUkFWSVNfUkVQT19TTFVHXCIsXG4gICAgICBcIlRSQVZJU19KT0JfTlVNQkVSXCIsXG4gICAgICBcIlRSQVZJU19FVkVOVF9UWVBFXCIsXG4gICAgICBcIlRSQVZJU19DT01NSVRfUkFOR0VcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIlRSQVZJU19QVUxMX1JFUVVFU1RfQlJBTkNIXCIsXG4gICAgICBcIlRSQVZJU19QVUxMX1JFUVVFU1RfU0hBXCIsXG4gICAgXSksXG4gICAgd2VyY2tlcjogbnVsbCxcbiAgICAvLyBodHRwczovL2RvY3MubmV0bGlmeS5jb20vY29uZmlndXJlLWJ1aWxkcy9lbnZpcm9ubWVudC12YXJpYWJsZXMvI2RlcGxveS11cmxzLWFuZC1tZXRhZGF0YVxuICAgIG5ldGxpZnk6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJDT05URVhUXCIsXG4gICAgICBcIlVSTFwiLFxuICAgICAgXCJERVBMT1lfVVJMXCIsXG4gICAgICBcIkRFUExPWV9QUklNRV9VUkxcIixcbiAgICAgIFwiREVQTE9ZX0lEXCIsXG4gICAgXSksXG4gICAgLy8gaHR0cHM6Ly9sYXllcmNpLmNvbS9kb2NzL2xheWVyZmlsZS1yZWZlcmVuY2UvYnVpbGQtZW52XG4gICAgbGF5ZXJjaTogZXh0cmFjdChbXG4gICAgICBcIkxBWUVSQ0lfSk9CX0lEXCIsXG4gICAgICBcIkxBWUVSQ0lfUlVOTkVSX0lEXCIsXG4gICAgICBcIlJFVFJZX0lOREVYXCIsXG4gICAgICBcIkxBWUVSQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkxBWUVSQ0lfUkVQT19OQU1FXCIsXG4gICAgICBcIkxBWUVSQ0lfUkVQT19PV05FUlwiLFxuICAgICAgXCJMQVlFUkNJX0JSQU5DSFwiLFxuICAgICAgXCJHSVRfVEFHXCIsIC8vIHNob3J0IGhleCBmb3IgY29tbWl0c1xuICAgIF0pLFxuICB9O1xufTtcblxuLy8gdHJpZXMgdG8gZ3JhYiBjb21taXQgaW5mb3JtYXRpb24gZnJvbSBDSSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbi8vIHZlcnkgdXNlZnVsIHRvIGZpbGwgbWlzc2luZyBpbmZvcm1hdGlvbiB3aGVuIEdpdCBjYW5ub3QgZ3JhYiBjb3JyZWN0IHZhbHVlc1xuY29uc3QgX3Byb3ZpZGVyQ29tbWl0UGFyYW1zID0gKCk6IFByb3ZpZGVyQ29tbWl0UGFyYW1zUmVzID0+IHtcbiAgY29uc3QgeyBlbnYgfSA9IHByb2Nlc3M7XG5cbiAgcmV0dXJuIHtcbiAgICBhcHB2ZXlvcjoge1xuICAgICAgc2hhOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVQsXG4gICAgICAvLyBzaW5jZSBBUFBWRVlPUl9SRVBPX0JSQU5DSCB3aWxsIGJlIHRoZSB0YXJnZXQgYnJhbmNoIG9uIGEgUFJcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIFBVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGUuZy4gaWYgeW91IGhhdmUgYSBQUjogZGV2ZWxvcCA8LSBteS1mZWF0dXJlLWJyYW5jaFxuICAgICAgLy8gbXktZmVhdHVyZS1icmFuY2ggaXMgQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0hcbiAgICAgIC8vIGRldmVsb3AgICAgICAgICAgIGlzIEFQUFZFWU9SX1JFUE9fQlJBTkNIXG4gICAgICBicmFuY2g6XG4gICAgICAgIGVudi5BUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSCB8fCBlbnYuQVBQVkVZT1JfUkVQT19CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBqb2luKFxuICAgICAgICBcIlxcblwiLFxuICAgICAgICBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfTUVTU0FHRSxcbiAgICAgICAgZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX01FU1NBR0VfRVhURU5ERURcbiAgICAgICksXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9BVVRIT1JfRU1BSUwsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBhd3NDb2RlQnVpbGQ6IHtcbiAgICAgIHNoYTogZW52LkNPREVCVUlMRF9SRVNPTFZFRF9TT1VSQ0VfVkVSU0lPTixcbiAgICAgIC8vIGJyYW5jaDogPz8/LFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkNPREVCVUlMRF9TT1VSQ0VfUkVQT19VUkwsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGF6dXJlOiB7XG4gICAgICBzaGE6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OLFxuICAgICAgYnJhbmNoOiBlbnYuQlVJTERfU09VUkNFQlJBTkNITkFNRSxcbiAgICAgIG1lc3NhZ2U6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5CVUlMRF9SRVFVRVNURURGT1JFTUFJTCxcbiAgICB9LFxuICAgIGJhbWJvbzoge1xuICAgICAgc2hhOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uLFxuICAgICAgYnJhbmNoOiBlbnYuYmFtYm9vX3BsYW5SZXBvc2l0b3J5X2JyYW5jaCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgYXV0aG9yTmFtZTogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV91c2VybmFtZSxcbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXBvc2l0b3J5VVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBiaXRidWNrZXQ6IHtcbiAgICAgIHNoYTogZW52LkJJVEJVQ0tFVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CSVRCVUNLRVRfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGJ1aWxka2l0ZToge1xuICAgICAgc2hhOiBlbnYuQlVJTERLSVRFX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkJVSUxES0lURV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERLSVRFX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERLSVRFX0JVSUxEX0NSRUFUT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkJVSUxES0lURV9CVUlMRF9DUkVBVE9SX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQlVJTERLSVRFX1JFUE8sXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuQlVJTERLSVRFX1BJUEVMSU5FX0RFRkFVTFRfQlJBTkNILFxuICAgIH0sXG4gICAgY2lyY2xlOiB7XG4gICAgICBzaGE6IGVudi5DSVJDTEVfU0hBMSxcbiAgICAgIGJyYW5jaDogZW52LkNJUkNMRV9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSVJDTEVfVVNFUk5BTUUsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DSVJDTEVfUkVQT1NJVE9SWV9VUkwsXG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVzaGlwQmFzaWM6IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9JRCxcbiAgICAgIGJyYW5jaDogZW52LkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DSV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSV9DT01NSVRURVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQ0lfQ09NTUlUVEVSX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgY29kZXNoaXBQcm86IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9JRCxcbiAgICAgIGJyYW5jaDogZW52LkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DSV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DSV9DT01NSVRURVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQ0lfQ09NTUlUVEVSX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgY29kZUZyZXNoOiB7XG4gICAgICBzaGE6IGVudi5DRl9SRVZJU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkNGX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DRl9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DRl9DT01NSVRfQVVUSE9SLFxuICAgIH0sXG4gICAgZHJvbmU6IHtcbiAgICAgIHNoYTogZW52LkRST05FX0NPTU1JVF9TSEEsXG4gICAgICAvLyBodHRwczovL2RvY3MuZHJvbmUuaW8vcGlwZWxpbmUvZW52aXJvbm1lbnQvcmVmZXJlbmNlL2Ryb25lLXNvdXJjZS1icmFuY2gvXG4gICAgICBicmFuY2g6IGVudi5EUk9ORV9TT1VSQ0VfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkRST05FX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkRST05FX0NPTU1JVF9BVVRIT1IsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkRST05FX0NPTU1JVF9BVVRIT1JfRU1BSUwsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5EUk9ORV9HSVRfSFRUUF9VUkwsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuRFJPTkVfUkVQT19CUkFOQ0gsXG4gICAgfSxcbiAgICBnaXRodWJBY3Rpb25zOiB7XG4gICAgICBzaGE6IGVudi5HSVRIVUJfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuR0hfQlJBTkNIIHx8IGVudi5HSVRIVUJfUkVGLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkdJVEhVQl9CQVNFX1JFRixcbiAgICAgIHJlbW90ZUJyYW5jaDogZW52LkdJVEhVQl9IRUFEX1JFRixcbiAgICAgIHJ1bkF0dGVtcHQ6IGVudi5HSVRIVUJfUlVOX0FUVEVNUFQsXG4gICAgfSxcbiAgICBnaXRsYWI6IHtcbiAgICAgIHNoYTogZW52LkNJX0NPTU1JVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5DSV9DT01NSVRfUkVGX05BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuR0lUTEFCX1VTRVJfTkFNRSxcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuR0lUTEFCX1VTRVJfRU1BSUwsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DSV9SRVBPU0lUT1JZX1VSTCxcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5DSV9ERUZBVUxUX0JSQU5DSCxcbiAgICB9LFxuICAgIGdvb2dsZUNsb3VkOiB7XG4gICAgICBzaGE6IGVudi5DT01NSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuQlJBTkNIX05BTUUsXG4gICAgICAvLyBtZXNzYWdlOiA/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/XG4gICAgfSxcbiAgICBqZW5raW5zOiB7XG4gICAgICBzaGE6IGVudi5HSVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuR0lUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICAvLyBPbmx5IGZyb20gZm9ya3M/IGh0dHBzOi8vc2VtYXBob3JlY2kuY29tL2RvY3MvYXZhaWxhYmxlLWVudmlyb25tZW50LXZhcmlhYmxlcy5odG1sXG4gICAgc2VtYXBob3JlOiB7XG4gICAgICBzaGE6IGVudi5TRU1BUEhPUkVfR0lUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LlNFTUFQSE9SRV9HSVRfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LlNFTUFQSE9SRV9HSVRfUkVQT19TTFVHLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBzaGlwcGFibGU6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5DT01NSVRURVIsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBzbmFwOiBudWxsLFxuICAgIHRlYW1jaXR5OiBudWxsLFxuICAgIHRlYW1mb3VuZGF0aW9uOiB7XG4gICAgICBzaGE6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OLFxuICAgICAgYnJhbmNoOiBlbnYuQlVJTERfU09VUkNFQlJBTkNITkFNRSxcbiAgICAgIG1lc3NhZ2U6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5CVUlMRF9TT1VSQ0VWRVJTSU9OQVVUSE9SLFxuICAgIH0sXG4gICAgdHJhdmlzOiB7XG4gICAgICBzaGE6IGVudi5UUkFWSVNfUFVMTF9SRVFVRVNUX1NIQSB8fCBlbnYuVFJBVklTX0NPTU1JVCxcbiAgICAgIC8vIGZvciBQUnMsIFRSQVZJU19CUkFOQ0ggaXMgdGhlIGJhc2UgYnJhbmNoIGJlaW5nIG1lcmdlZCBpbnRvXG4gICAgICBicmFuY2g6IGVudi5UUkFWSVNfUFVMTF9SRVFVRVNUX0JSQU5DSCB8fCBlbnYuVFJBVklTX0JSQU5DSCxcbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgbWVzc2FnZTogZW52LlRSQVZJU19DT01NSVRfTUVTU0FHRSxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIHdlcmNrZXI6IG51bGwsXG4gICAgbmV0bGlmeToge1xuICAgICAgc2hhOiBlbnYuQ09NTUlUX1JFRixcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LlJFUE9TSVRPUllfVVJMLFxuICAgIH0sXG4gICAgbGF5ZXJjaToge1xuICAgICAgc2hhOiBlbnYuR0lUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkxBWUVSQ0lfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkdJVF9DT01NSVRfVElUTEUsXG4gICAgfSxcbiAgfTtcbn07XG5cbnR5cGUgQ2lQcm92aWRlckRhdGEgPSB7XG4gIHNoYT86IHN0cmluZztcbiAgYnJhbmNoPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBhdXRob3JOYW1lPzogc3RyaW5nO1xuICBhdXRob3JFbWFpbD86IHN0cmluZztcbiAgcmVtb3RlT3JpZ2luPzogc3RyaW5nO1xuICBkZWZhdWx0QnJhbmNoPzogc3RyaW5nO1xuICByZW1vdGVCcmFuY2g/OiBzdHJpbmc7XG4gIHJ1bkF0dGVtcHQ/OiBzdHJpbmc7XG4gIGdoYUV2ZW50RGF0YT86IEdoYUV2ZW50RGF0YTtcbn07XG5cbmludGVyZmFjZSBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyB7XG4gIFtrZXk6IHN0cmluZ106IENpUHJvdmlkZXJEYXRhIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFByb3ZpZGVyQ2lQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgX2dldCA9IChmbjogKCkgPT4gUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgfCBQcm92aWRlckNpUGFyYW1zUmVzKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlck5hbWUpIHJldHVybiB7fTtcblxuICByZXR1cm4gXy5jaGFpbihmbigpKS5nZXQocHJvdmlkZXJOYW1lKS52YWx1ZSgpO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBubyBidWlsZCBJRCBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYnkgdXNlclxuICogQ2hlY2sgaWYgd2UgY2FuIGZldGNoIGl0IGF1dG9tYXRpY2FsbHkgZnJvbSBDSSB2YXJpYWJsZXMuXG4gKiBUaGUgcHJvY2VzcyB3aWxsIHN0b3AgaWYgd2UgY2Fubm90IGRvIGl0XG4gKiBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvcmVmZXJlbmNlcy9lcnJvci1tZXNzYWdlcyNXZS1jb3VsZC1ub3QtZGV0ZXJtaW5lLWEtdW5pcXVlLUNJLWJ1aWxkLUlEXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShjaVByb3ZpZGVyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChjaVByb3ZpZGVyICYmIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKS5pbmNsdWRlcyhjaVByb3ZpZGVyKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIENJIGJ1aWxkIElEIGZyb20gdGhlIGVudmlyb25tZW50LiBQbGVhc2UgcHJvdmlkZSBhIHVuaXF1ZSBDSSBidWlsZCBJRCB1c2luZyB0aGUgLS1jaS1idWlsZC1pZCBDTEkgZmxhZyBvciAnY2lCdWlsZElkJyBwYXJhbWV0ZXIgZm9yICdydW4nIG1ldGhvZC5gXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0KCkge1xuICByZXR1cm4gXy5rZXlzKENJX1BST1ZJREVSUyk7XG59XG5cbi8vIGdyYWIgYWxsIGRldGVjdGFibGUgcHJvdmlkZXJzXG4vLyB0aGF0IHdlIGNhbiBleHRyYWN0IGNpQnVpbGRJZCBmcm9tXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0YWJsZUNpQnVpbGRJZFByb3ZpZGVycygpIHtcbiAgcmV0dXJuIF8uY2hhaW4oX3Byb3ZpZGVyQ2lQYXJhbXMoKSkub21pdEJ5KF8uaXNOdWxsKS5rZXlzKCkudmFsdWUoKTtcbn1cblxuZXhwb3J0IHR5cGUgQ2lQcm92aWRlciA9IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaVByb3ZpZGVyKCk6IENpUHJvdmlkZXIge1xuICByZXR1cm4gX2RldGVjdFByb3ZpZGVyTmFtZSgpIHx8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIENpUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNpUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFBhcmFtcygpIHtcbiAgcmV0dXJuIF9nZXQoX3Byb3ZpZGVyQ29tbWl0UGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENJKGNpQnVpbGRJZD86IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSBnZXRDaVBhcmFtcygpIGFzIENpUGFyYW1zO1xuICBjb25zdCBwcm92aWRlciA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFjaUJ1aWxkSWQpIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShwcm92aWRlcik7XG5cbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwcm92aWRlcjogJXNcIiwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcImRldGVjdGVkIENJIHBhcmFtczogJU9cIiwgcGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcHJvdmlkZXIsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21taXREZWZhdWx0cyhleGlzdGluZ0luZm86IENpUHJvdmlkZXJEYXRhKSB7XG4gIGRlYnVnKFwiZ2l0IGNvbW1pdCBleGlzdGluZyBpbmZvXCIpO1xuICBkZWJ1ZyhleGlzdGluZ0luZm8pO1xuXG4gIGNvbnN0IGNvbW1pdFBhcmFtc09iaiA9IGdldENvbW1pdFBhcmFtcygpO1xuXG4gIGRlYnVnKFwiY29tbWl0IGluZm8gZnJvbSBwcm92aWRlciBlbnZpcm9ubWVudCB2YXJpYWJsZXM6ICVPXCIsIGNvbW1pdFBhcmFtc09iaik7XG5cbiAgLy8gYmFzZWQgb24gdGhlIGV4aXN0aW5nSW5mbyBwcm9wZXJ0aWVzXG4gIC8vIG1lcmdlIGluIHRoZSBjb21taXRQYXJhbXMgaWYgbnVsbCBvciB1bmRlZmluZWRcbiAgLy8gZGVmYXVsdGluZyBiYWNrIHRvIG51bGwgaWYgYWxsIGZhaWxzXG4gIC8vIE5PVEU6IG9ubHkgcHJvcGVydGllcyBkZWZpbmVkIGluIFwiZXhpc3RpbmdJbmZvXCIgd2lsbCBiZSByZXR1cm5lZFxuICBjb25zdCBjb21iaW5lZCA9IF8udHJhbnNmb3JtKFxuICAgIGV4aXN0aW5nSW5mbyxcbiAgICAoXG4gICAgICBtZW1vOiB7IFttZW1vS2V5OiBzdHJpbmddOiBzdHJpbmcgfCBHaGFFdmVudERhdGEgfCBudWxsIH0sXG4gICAgICB2YWx1ZTogc3RyaW5nIHwgR2hhRXZlbnREYXRhLFxuICAgICAga2V5OiBzdHJpbmdcbiAgICApID0+IHtcbiAgICAgIHJldHVybiAobWVtb1trZXldID0gXy5kZWZhdWx0VG8oXG4gICAgICAgIHZhbHVlIHx8IGNvbW1pdFBhcmFtc09ialtrZXkgYXMga2V5b2YgQ2lQcm92aWRlcl0sXG4gICAgICAgIG51bGxcbiAgICAgICkpO1xuICAgIH1cbiAgKTtcblxuICBkZWJ1ZyhcImNvbWJpbmVkIGdpdCBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gcHJvdmlkZXJcIik7XG4gIGRlYnVnKGNvbWJpbmVkKTtcblxuICByZXR1cm4gY29tYmluZWQ7XG59XG4iLCAiaW1wb3J0IGZzIGZyb20gXCJmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRDb3ZlcmFnZUZpbGVQYXRoID0gYXN5bmMgKFxuICBjb3ZlcmFnZUZpbGUgPSBcIi4vLm55Y19vdXRwdXQvb3V0Lmpzb25cIlxuKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBqb2luKHByb2Nlc3MuY3dkKCksIGNvdmVyYWdlRmlsZSk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5hY2Nlc3MocGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZmFsc2UsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yLFxuICAgIH07XG4gIH1cbn07XG4iLCAiaW1wb3J0IGN5cHJlc3MgZnJvbSBcImN5cHJlc3NcIjtcbmltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1Jlc3VsdCxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IHNhZmUgfSBmcm9tIFwiLi4vbGFuZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldFdTU1BvcnQgfSBmcm9tIFwiLi4vd3NcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmN5cHJlc3NcIik7XG5pbnRlcmZhY2UgUnVuQ3lwcmVzc1NwZWNGaWxlIHtcbiAgc3BlYzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuQmFyZUN5cHJlc3MocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSB7fSkge1xuICAvLyByZXZlcnQgY3VycmVudHMgcGFyYW1zIHRvIGN5cHJlc3MgcGFyYW1zXG4gIC8vIGV4Y2x1ZGUgcmVjb3JkIG1vZGUgcGFyYW1zXG4gIGNvbnN0IHAgPSB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGNpQnVpbGRJZDogdW5kZWZpbmVkLFxuICAgIHRhZzogdW5kZWZpbmVkLFxuICAgIHBhcmFsbGVsOiB1bmRlZmluZWQsXG4gICAgcmVjb3JkOiBmYWxzZSxcbiAgICBncm91cDogdW5kZWZpbmVkLFxuICAgIHNwZWM6IF8uZmxhdHRlbihwYXJhbXMuc3BlYykuam9pbihcIixcIiksXG4gIH07XG4gIGRlYnVnKFwiUnVubmluZyBiYXJlIEN5cHJlc3Mgd2l0aCBwYXJhbXMgJW9cIiwgcCk7XG4gIHJldHVybiBjeXByZXNzLnJ1bihwKTtcbn1cblxuLyoqXG4gKiBSdW4gQ3lwcmVzcyB0ZXN0cywgd2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIHN0cmlwcGVkIG9wdGlvbnMgYXMgaWYgd2UndmUgcmVjZWl2ZWQgdGhlbSBmcm9tIHRoZSBDTElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blNwZWNGaWxlKFxuICB7IHNwZWMgfTogUnVuQ3lwcmVzc1NwZWNGaWxlLFxuICBjeXByZXNzUnVuT3B0aW9uczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pIHtcbiAgY29uc3QgcnVuQVBJT3B0aW9ucyA9IGdldEN5cHJlc3NSdW5BUElQYXJhbXMoY3lwcmVzc1J1bk9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ucnVuQVBJT3B0aW9ucyxcbiAgICBjb25maWc6IHtcbiAgICAgIC4uLnJ1bkFQSU9wdGlvbnMuY29uZmlnLFxuICAgICAgdHJhc2hBc3NldHNCZWZvcmVSdW5zOiBmYWxzZSxcbiAgICB9LFxuICAgIGVudjoge1xuICAgICAgLi4ucnVuQVBJT3B0aW9ucy5lbnYsXG4gICAgICBjdXJyZW50c193czogZ2V0V1NTUG9ydCgpLFxuICAgIH0sXG4gICAgc3BlYyxcbiAgfTtcbiAgZGVidWcoXCJydW5uaW5nIGN5cHJlc3Mgd2l0aCBvcHRpb25zICVvXCIsIG9wdGlvbnMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjeXByZXNzLnJ1bihvcHRpb25zKTtcblxuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgIHdhcm4oJ0N5cHJlc3MgcnVubmVyIGZhaWxlZCB3aXRoIG1lc3NhZ2U6IFwiJXNcIicsIHJlc3VsdC5tZXNzYWdlKTtcbiAgICB3YXJuKFxuICAgICAgXCJUaGUgZm9sbG93aW5nIHNwZWMgZmlsZXMgd2lsbCBiZSBtYXJrZWQgYXMgZmFpbGVkOiAlc1wiLFxuICAgICAgc3BlY1xuICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgIC5tYXAoKGkpID0+IGBcXG4gLSAke2l9YClcbiAgICAgICAgLmpvaW4oXCJcIilcbiAgICApO1xuICB9XG4gIGRlYnVnKFwiY3lwcmVzcyBydW4gcmVzdWx0ICVvXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjb25zdCBydW5TcGVjRmlsZVNhZmUgPSAoXG4gIHNwZWM6IFJ1bkN5cHJlc3NTcGVjRmlsZSxcbiAgY3lwcmVzc1J1bk9wdGlvbnM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxDeXByZXNzUmVzdWx0PiA9PlxuICBzYWZlKFxuICAgIHJ1blNwZWNGaWxlLFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDeXByZXNzIHJ1bm5uZXIgY3Jhc2hlZCB3aXRoIGFuIGVycm9yOlxcbiR7XG4gICAgICAgIChlcnJvciBhcyBFcnJvcikubWVzc2FnZVxuICAgICAgfVxcbiR7KGVycm9yIGFzIEVycm9yKS5zdGFja319YDtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBydW4gZXhjZXB0aW9uICVvXCIsIGVycm9yKTtcbiAgICAgIHdhcm4oJ0N5cHJlc3MgcnVubmVyIGNyYXNoZWQ6IFwiJXNcIicsIG1lc3NhZ2UpO1xuICAgICAgd2FybihcbiAgICAgICAgXCJUaGUgZm9sbG93aW5nIHNwZWMgZmlsZXMgd2lsbCBiZSBtYXJrZWQgYXMgZmFpbGVkOiAlc1wiLFxuICAgICAgICBzcGVjLnNwZWNcbiAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgLm1hcCgoaSkgPT4gYFxcbiAtICR7aX1gKVxuICAgICAgICAgIC5qb2luKFwiXCIpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcImZhaWxlZFwiIGFzIGNvbnN0LFxuICAgICAgICBmYWlsdXJlczogMSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICAoKSA9PiB7fVxuICApKHNwZWMsIGN5cHJlc3NSdW5PcHRpb25zKTtcbiIsICJpbXBvcnQgYmx1ZWJpcmQgZnJvbSBcImJsdWViaXJkXCI7XG5cbmJsdWViaXJkLlByb21pc2UuY29uZmlnKHtcbiAgY2FuY2VsbGF0aW9uOiB0cnVlLFxufSk7XG5leHBvcnQgY29uc3QgQlByb21pc2UgPSBibHVlYmlyZC5Qcm9taXNlO1xuXG5leHBvcnQgY29uc3Qgc2FmZSA9XG4gIDxUIGV4dGVuZHMgYW55W10sIFIgZXh0ZW5kcyBhbnksIEYgZXh0ZW5kcyBhbnk+KFxuICAgIGZuOiAoLi4uYXJnczogVCkgPT4gUHJvbWlzZTxSPixcbiAgICBpZkZhbGVkOiAoZTogdW5rbm93bikgPT4gRixcbiAgICBpZlN1Y2NlZWQ6ICgpID0+IGFueVxuICApID0+XG4gIGFzeW5jICguLi5hcmdzOiBUKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICAgIGlmU3VjY2VlZCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGlmRmFsZWQoZSk7XG4gICAgfVxuICB9O1xuIiwgImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IG1hdGNoLCBQIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuUGFyYW1ldGVycywgRGVidWdNb2RlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmVudW0gRGVidWdUb2tlbnMge1xuICBDdXJyZW50cyA9IFwiY3VycmVudHM6KlwiLFxuICBDeXByZXNzID0gXCJjeXByZXNzOipcIixcbiAgQ29tbWl0SW5mbyA9IFwiY29tbWl0LWluZm9cIixcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZURlYnVnKG1vZGU6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcImNsb3VkRGVidWdcIl0pIHtcbiAgbWF0Y2gobW9kZSlcbiAgICAud2l0aChQLmluc3RhbmNlT2YoQXJyYXkpLCAoaSkgPT4gaS5mb3JFYWNoKHNldERlYnVnTW9kZSkpXG4gICAgLndpdGgodHJ1ZSwgKCkgPT4gc2V0RGVidWdNb2RlKERlYnVnTW9kZS5BbGwpKVxuICAgIC53aXRoKFxuICAgICAgUC51bmlvbihcbiAgICAgICAgRGVidWdNb2RlLkFsbCxcbiAgICAgICAgRGVidWdNb2RlLkN1cnJlbnRzLFxuICAgICAgICBEZWJ1Z01vZGUuQ3lwcmVzcyxcbiAgICAgICAgRGVidWdNb2RlLkNvbW1pdEluZm9cbiAgICAgICksXG4gICAgICAoaSkgPT4gc2V0RGVidWdNb2RlKGkpXG4gICAgKVxuICAgIC5vdGhlcndpc2UoKCkgPT4gc2V0RGVidWdNb2RlKERlYnVnTW9kZS5Ob25lKSk7XG59XG5cbmZ1bmN0aW9uIHNldERlYnVnTW9kZShtb2RlOiBzdHJpbmcpIHtcbiAgaWYgKG1vZGUgPT09IERlYnVnTW9kZS5Ob25lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdG9rZW5zID0gbmV3IFNldChwcm9jZXNzLmVudi5ERUJVRyA/IHByb2Nlc3MuZW52LkRFQlVHLnNwbGl0KFwiLFwiKSA6IFtdKTtcbiAgbWF0Y2gobW9kZSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQWxsLCAoKSA9PiB7XG4gICAgICB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkNvbW1pdEluZm8pO1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DdXJyZW50cyk7XG4gICAgICB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN5cHJlc3MpO1xuICAgIH0pXG4gICAgLndpdGgoRGVidWdNb2RlLkN1cnJlbnRzLCAoKSA9PiB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN1cnJlbnRzKSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQ3lwcmVzcywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DeXByZXNzKSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQ29tbWl0SW5mbywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5Db21taXRJbmZvKSlcbiAgICAub3RoZXJ3aXNlKCgpID0+IHt9KTtcblxuICBkZWJ1Zy5lbmFibGUoQXJyYXkuZnJvbSh0b2tlbnMpLmpvaW4oXCIsXCIpKTtcbn1cbiIsICJpbXBvcnQgeyBnZXRBUElCYXNlVXJsIH0gZnJvbSBcIi4vaHR0cENsaWVudC9jb25maWdcIjtcblxuZXhwb3J0IGNvbnN0IGlzQ3VycmVudHMgPSAoKSA9PlxuICAhIXByb2Nlc3MuZW52LkNVUlJFTlRTX0VORk9SQ0VfSVNfQ1VSUkVOVFMgfHxcbiAgZ2V0QVBJQmFzZVVybCgpID09PSBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgY29tbWl0SW5mbyB9IGZyb20gXCJAY3VycmVudHMvY29tbWl0LWluZm9cIjtcbmltcG9ydCB7IGdldENvbW1pdERlZmF1bHRzIH0gZnJvbSBcIi4vY2lQcm92aWRlclwiO1xuXG5leHBvcnQgdHlwZSBHaGFFdmVudERhdGEgPSB7XG4gIGhlYWRSZWY6IHN0cmluZztcbiAgaGVhZFNoYTogc3RyaW5nO1xuICBiYXNlUmVmOiBzdHJpbmc7XG4gIGJhc2VTaGE6IHN0cmluZztcbiAgaXNzdWVVcmw6IHN0cmluZztcbiAgaHRtbFVybDogc3RyaW5nO1xuICBwclRpdGxlOiBzdHJpbmc7XG4gIHNlbmRlckF2YXRhclVybDogc3RyaW5nO1xuICBzZW5kZXJIdG1sVXJsOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0R2l0SW5mbyA9IGFzeW5jIChwcm9qZWN0Um9vdDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvbW1pdCA9IGF3YWl0IGNvbW1pdEluZm8ocHJvamVjdFJvb3QpO1xuICByZXR1cm4gZ2V0Q29tbWl0RGVmYXVsdHMoe1xuICAgIGJyYW5jaDogY29tbWl0LmJyYW5jaCxcbiAgICByZW1vdGVPcmlnaW46IGNvbW1pdC5yZW1vdGUsXG4gICAgYXV0aG9yRW1haWw6IGNvbW1pdC5lbWFpbCxcbiAgICBhdXRob3JOYW1lOiBjb21taXQuYXV0aG9yLFxuICAgIG1lc3NhZ2U6IGNvbW1pdC5tZXNzYWdlLFxuICAgIHNoYTogY29tbWl0LnNoYSxcbiAgICBnaGFFdmVudERhdGE6IGNvbW1pdC5naGFFdmVudERhdGEsXG4gIH0pO1xufTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBEZXRlY3RlZEJyb3dzZXIsIFBsYXRmb3JtIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6YnJvd3NlclwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGd1ZXNzQnJvd3NlcihcbiAgYnJvd3Nlcjogc3RyaW5nLFxuICBhdmFpbGFibGVCcm93c2VyczogRGV0ZWN0ZWRCcm93c2VyW10gPSBbXVxuKTogUGljazxQbGF0Zm9ybSwgXCJicm93c2VyTmFtZVwiIHwgXCJicm93c2VyVmVyc2lvblwiPiB7XG4gIGRlYnVnKFxuICAgIFwiZ3Vlc3NpbmcgYnJvd3NlciBmcm9tICclcycsIGF2YWlsYWJsZSBicm93c2VyczogJW9cIixcbiAgICBicm93c2VyLFxuICAgIGF2YWlsYWJsZUJyb3dzZXJzXG4gICk7XG4gIC8vIHRyeSBpZGVudGlmeWluZyB0aGUgYnJvd3NlciBieSBuYW1lIGZpcnN0XG4gIGxldCByZXN1bHQgPSBhdmFpbGFibGVCcm93c2Vycy5maW5kKChiKSA9PiBiLm5hbWUgPT09IGJyb3dzZXIpO1xuXG4gIGlmIChyZXN1bHQpIHtcbiAgICBkZWJ1ZyhcImlkZW50aWZpZWQgYnJvd3NlciBieSBuYW1lOiAlb1wiLCByZXN1bHQpO1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyTmFtZTogcmVzdWx0LmRpc3BsYXlOYW1lLFxuICAgICAgYnJvd3NlclZlcnNpb246IHJlc3VsdC52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHRyeSBpZGVudGlmeWluZyBieSB0aGUgcGF0aFxuICByZXN1bHQgPSBhdmFpbGFibGVCcm93c2Vycy5maW5kKChiKSA9PiBiLnBhdGggPT09IGJyb3dzZXIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgZGVidWcoXCJpZGVudGlmaWVkIGJyb3dzZXIgYnkgcGF0aDogJW9cIiwgcmVzdWx0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3Nlck5hbWU6IHJlc3VsdC5kaXNwbGF5TmFtZSA/PyByZXN1bHQubmFtZSxcbiAgICAgIGJyb3dzZXJWZXJzaW9uOiByZXN1bHQudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgd2FybihcIlVuYWJsZSB0byBpZGVudGlmeSBicm93c2VyIG5hbWUgYW5kIHZlcnNpb25cIik7XG5cbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gZHVtbXkgYnJvd3NlclxuICByZXR1cm4ge1xuICAgIGJyb3dzZXJOYW1lOiBcInVua25vd25cIixcbiAgICBicm93c2VyVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gIH07XG59XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGdldG9zIGZyb20gXCJnZXRvc1wiO1xuaW1wb3J0IHsgY3B1cywgZnJlZW1lbSwgcGxhdGZvcm0sIHJlbGVhc2UsIHRvdGFsbWVtIH0gZnJvbSBcIm9zXCI7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tIFwidXRpbFwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cGxhdGZvcm1cIik7XG5cbmNvbnN0IGdldE9zVmVyc2lvbiA9IGFzeW5jICgpID0+IHtcbiAgaWYgKHBsYXRmb3JtKCkgPT09IFwibGludXhcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaW51eE9zID0gYXdhaXQgcHJvbWlzaWZ5KGdldG9zKSgpO1xuICAgICAgaWYgKFwiZGlzdFwiIGluIGxpbnV4T3MgJiYgXCJyZWxlYXNlXCIgaW4gbGludXhPcykge1xuICAgICAgICByZXR1cm4gW2xpbnV4T3MuZGlzdCwgbGludXhPcy5yZWxlYXNlXS5qb2luKFwiIC0gXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxlYXNlKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UGxhdGZvcm1JbmZvID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBvc1ZlcnNpb24gPSBhd2FpdCBnZXRPc1ZlcnNpb24oKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9zTmFtZTogcGxhdGZvcm0oKSxcbiAgICBvc1ZlcnNpb24sXG4gICAgb3NDcHVzOiBjcHVzKCksXG4gICAgb3NNZW1vcnk6IHtcbiAgICAgIGZyZWU6IGZyZWVtZW0oKSxcbiAgICAgIHRvdGFsOiB0b3RhbG1lbSgpLFxuICAgIH0sXG4gIH07XG4gIGRlYnVnKFwicGxhdGZvcm0gaW5mbzogJW9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCAiaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgZ3Vlc3NCcm93c2VyIH0gZnJvbSBcIi4vYnJvd3NlclwiO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm1JbmZvIH0gZnJvbSBcIi4vcGxhdGZvcm1cIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXRmb3JtKHtcbiAgYnJvd3NlcixcbiAgY29uZmlnLFxufToge1xuICBicm93c2VyPzogc3RyaW5nO1xuICBjb25maWc6IE1lcmdlZENvbmZpZztcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi4oYXdhaXQgZ2V0UGxhdGZvcm1JbmZvKCkpLFxuICAgIC4uLmd1ZXNzQnJvd3Nlcihicm93c2VyID8/IFwiZWxlY3Ryb25cIiwgY29uZmlnLnJlc29sdmVkPy5icm93c2VycyksXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgQ3lwcmVzc1Jlc3VsdCwgU2NyZWVuc2hvdEFydGlmYWN0IH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7XG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBUZXN0U3RhdGUsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQsXG59IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXN1bHRzXCIpO1xuXG5leHBvcnQgY29uc3QgaXNTdWNjZXNzUmVzdWx0ID0gKFxuICByZXN1bHQ6IEN5cHJlc3NSZXN1bHRcbik6IHJlc3VsdCBpcyBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCA9PiB7XG4gIHJldHVybiByZXN1bHQuc3RhdHVzID09PSBcImZpbmlzaGVkXCI7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2NyZWVuc2hvdHNTdW1tYXJ5ID0gKFxuICB0ZXN0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlRlc3RSZXN1bHRbXSA9IFtdXG4pOiBTY3JlZW5zaG90QXJ0aWZhY3RbXSA9PiB7XG4gIHJldHVybiB0ZXN0cy5mbGF0TWFwKCh0ZXN0LCBpKSA9PlxuICAgIHRlc3QuYXR0ZW1wdHMuZmxhdE1hcCgoYSwgYWkpID0+XG4gICAgICBhLnNjcmVlbnNob3RzLmZsYXRNYXAoKHMpID0+ICh7XG4gICAgICAgIC4uLnMsXG4gICAgICAgIHRlc3RJZDogYHIke2l9YCxcbiAgICAgICAgdGVzdEF0dGVtcHRJbmRleDogYWksXG4gICAgICAgIHNjcmVlbnNob3RJZDogbmFub2lkKCksXG4gICAgICB9KSlcbiAgICApXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3RhdHMgPSAoc3RhdHM6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHRbXCJzdGF0c1wiXSkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRzLFxuICAgIHdhbGxDbG9ja0R1cmF0aW9uOiBzdGF0cy5kdXJhdGlvbixcbiAgICB3YWxsQ2xvY2tTdGFydGVkQXQ6IHN0YXRzLnN0YXJ0ZWRBdCxcbiAgICB3YWxsQ2xvY2tFbmRlZEF0OiBzdGF0cy5lbmRlZEF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRlc3RBdHRlbXB0ID0gKGF0dGVtcHQ6IEN5cHJlc3NDb21tYW5kTGluZS5BdHRlbXB0UmVzdWx0KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0ZW1wdCxcbiAgICBzdGF0ZTogYXR0ZW1wdC5zdGF0ZSBhcyBUZXN0U3RhdGUsXG4gICAgd2FsbENsb2NrRHVyYXRpb246IGF0dGVtcHQuZHVyYXRpb24sXG4gICAgd2FsbENsb2NrU3RhcnRlZEF0OiBhdHRlbXB0LnN0YXJ0ZWRBdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZ1xuKTogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCA9PiB7XG4gIHJldHVybiB7XG4gICAgc3RhdHM6IGdldFN0YXRzKHJ1blJlc3VsdC5zdGF0cyksXG4gICAgcmVwb3J0ZXJTdGF0czogcnVuUmVzdWx0LnJlcG9ydGVyU3RhdHMsXG4gICAgZXhjZXB0aW9uOiBydW5SZXN1bHQuZXJyb3IgPz8gbnVsbCxcbiAgICB2aWRlbzogISFydW5SZXN1bHQudmlkZW8sIC8vIERpZCB0aGUgaW5zdGFuY2UgZ2VuZXJhdGUgYSB2aWRlbz9cbiAgICBzY3JlZW5zaG90czogZ2V0U2NyZWVuc2hvdHNTdW1tYXJ5KHJ1blJlc3VsdC50ZXN0cyA/PyBbXSksXG4gICAgaGFzQ292ZXJhZ2U6ICEhY292ZXJhZ2VGaWxlUGF0aCxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICBkaXNwbGF5RXJyb3I6IHRlc3QuZGlzcGxheUVycm9yLFxuICAgICAgICBzdGF0ZTogdGVzdC5zdGF0ZSBhcyBUZXN0U3RhdGUsXG4gICAgICAgIGhvb2tzOiBydW5SZXN1bHQuaG9va3MsXG4gICAgICAgIGF0dGVtcHRzOiB0ZXN0LmF0dGVtcHRzPy5tYXAoZ2V0VGVzdEF0dGVtcHQpID8/IFtdLFxuICAgICAgICBjbGllbnRJZDogYHIke2l9YCxcbiAgICAgIH0pKSA/PyBbXSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24oXG4gIGVycm9yOiBzdHJpbmcsXG4gIHN0YXRzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wic3RhdHNcIl1cbikge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICAgIGJvZHk6IFwiXCIsXG4gICAgZGlzcGxheUVycm9yOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICBob29rczogW10sXG4gICAgYXR0ZW1wdHM6IFtcbiAgICAgIGdldFRlc3RBdHRlbXB0KHtcbiAgICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICAgICAgICBzdGFjazogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGF0cy5zdGFydGVkQXQsXG4gICAgICAgIHZpZGVvVGltZXN0YW1wOiAwLFxuICAgICAgfSksXG4gICAgXSxcbiAgICBjbGllbnRJZDogXCJyMFwiLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9uc1xuKTogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgICBib2R5OiB0ZXN0LmJvZHksXG4gICAgICAgIGNsaWVudElkOiBgciR7aX1gLFxuICAgICAgICBob29rSWRzOiBbXSxcbiAgICAgIH0pKSA/PyBbXSxcbiAgICBob29rczogcnVuUmVzdWx0Lmhvb2tzLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcml6ZVRlc3RSZXN1bHRzID0gKFxuICBpbnB1dDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRbXSxcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgaWYgKCFpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhjb25maWcpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcmFsbCA9IGlucHV0LnJlZHVjZShcbiAgICAoXG4gICAgICBhY2MsXG4gICAgICB7XG4gICAgICAgIHRvdGFsRHVyYXRpb24sXG4gICAgICAgIHRvdGFsRmFpbGVkLFxuICAgICAgICB0b3RhbFBhc3NlZCxcbiAgICAgICAgdG90YWxQZW5kaW5nLFxuICAgICAgICB0b3RhbFNraXBwZWQsXG4gICAgICAgIHRvdGFsVGVzdHMsXG4gICAgICAgIHRvdGFsU3VpdGVzLFxuICAgICAgfVxuICAgICkgPT4gKHtcbiAgICAgIHRvdGFsRHVyYXRpb246IGFjYy50b3RhbER1cmF0aW9uICsgdG90YWxEdXJhdGlvbixcbiAgICAgIHRvdGFsU3VpdGVzOiBhY2MudG90YWxTdWl0ZXMgKyB0b3RhbFN1aXRlcyxcbiAgICAgIHRvdGFsUGVuZGluZzogYWNjLnRvdGFsUGVuZGluZyArIHRvdGFsUGVuZGluZyxcbiAgICAgIHRvdGFsRmFpbGVkOiBhY2MudG90YWxGYWlsZWQgKyB0b3RhbEZhaWxlZCxcbiAgICAgIHRvdGFsU2tpcHBlZDogYWNjLnRvdGFsU2tpcHBlZCArIHRvdGFsU2tpcHBlZCxcbiAgICAgIHRvdGFsUGFzc2VkOiBhY2MudG90YWxQYXNzZWQgKyB0b3RhbFBhc3NlZCxcbiAgICAgIHRvdGFsVGVzdHM6IGFjYy50b3RhbFRlc3RzICsgdG90YWxUZXN0cyxcbiAgICB9KSxcbiAgICBlbXB0eVN0YXRzXG4gICk7XG4gIGNvbnN0IGZpcnN0UmVzdWx0ID0gaW5wdXRbMF07XG4gIGNvbnN0IHN0YXJ0SXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuc3RhcnRlZFRlc3RzQXQpLnNvcnQoKTtcbiAgY29uc3QgZW5kSXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuZW5kZWRUZXN0c0F0KS5zb3J0KCk7XG4gIGNvbnN0IHJ1bnMgPSBpbnB1dC5tYXAoKGkpID0+IGkucnVucykuZmxhdCgpO1xuICByZXR1cm4ge1xuICAgIC4uLm92ZXJhbGwsXG4gICAgcnVucyxcbiAgICBzdGFydGVkVGVzdHNBdDogXy5maXJzdChzdGFydEl0ZW1zKSBhcyBzdHJpbmcsXG4gICAgZW5kZWRUZXN0c0F0OiBfLmxhc3QoZW5kSXRlbXMpIGFzIHN0cmluZyxcbiAgICAuLi5fLnBpY2soXG4gICAgICBmaXJzdFJlc3VsdCxcbiAgICAgIFwiYnJvd3Nlck5hbWVcIixcbiAgICAgIFwiYnJvd3NlclZlcnNpb25cIixcbiAgICAgIFwiYnJvd3NlclBhdGhcIixcbiAgICAgIFwib3NOYW1lXCIsXG4gICAgICBcIm9zVmVyc2lvblwiLFxuICAgICAgXCJjeXByZXNzVmVyc2lvblwiLFxuICAgICAgXCJjb25maWdcIlxuICAgICksXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5lbXB0eVN0YXRzLFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgcnVuczogW10sXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZyxcbiAgfTtcbn1cbmNvbnN0IGVtcHR5U3RhdHMgPSB7XG4gIHRvdGFsRHVyYXRpb246IDAsXG4gIHRvdGFsU3VpdGVzOiAwLFxuICB0b3RhbFBlbmRpbmc6IDAsXG4gIHRvdGFsRmFpbGVkOiAwLFxuICB0b3RhbFNraXBwZWQ6IDAsXG4gIHRvdGFsUGFzc2VkOiAwLFxuICB0b3RhbFRlc3RzOiAwLFxufTtcblxuY29uc3QgZ2V0RHVtbXlGYWlsZWRUZXN0ID0gKHN0YXJ0OiBzdHJpbmcsIGVycm9yOiBzdHJpbmcpID0+ICh7XG4gIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgYm9keTogXCIvLyBUaGlzIHRlc3QgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZHVlIHRvIGV4ZWN1dGlvbiBmYWlsdXJlXCIsXG4gIGRpc3BsYXlFcnJvcjogZXJyb3IsXG4gIGF0dGVtcHRzOiBbXG4gICAge1xuICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICB2aWRlb1RpbWVzdGFtcDogMCxcbiAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIG5hbWU6IFwiQ3lwcmVzc0V4ZWN1dGlvbkVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICBzdGFjazogXCJcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHNwZWNzLFxuICAgIGVycm9yLFxuICB9OiB7XG4gICAgc3BlY3M6IHN0cmluZ1tdO1xuICAgIGVycm9yOiBzdHJpbmc7XG4gIH1cbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnOiBjb25maWdTdGF0ZS5nZXRDb25maWcoKSA/PyB7fSxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICBzdGFydGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGVuZGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHRvdGFsRHVyYXRpb246IDAsXG4gICAgdG90YWxTdWl0ZXM6IDEsXG4gICAgdG90YWxGYWlsZWQ6IDEsXG4gICAgdG90YWxQYXNzZWQ6IDAsXG4gICAgdG90YWxQZW5kaW5nOiAwLFxuICAgIHRvdGFsU2tpcHBlZDogMCxcbiAgICB0b3RhbFRlc3RzOiAxLFxuICAgIGJyb3dzZXJOYW1lOiBcInVua25vd25cIixcbiAgICBicm93c2VyVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclBhdGg6IFwidW5rbm93blwiLFxuICAgIG9zTmFtZTogXCJ1bmtub3duXCIsXG4gICAgb3NWZXJzaW9uOiBcInVua25vd25cIixcbiAgICBjeXByZXNzVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgcnVuczogc3BlY3MubWFwKChzKSA9PiAoe1xuICAgICAgc3RhdHM6IHtcbiAgICAgICAgc3VpdGVzOiAxLFxuICAgICAgICB0ZXN0czogMSxcbiAgICAgICAgcGFzc2VzOiAwLFxuICAgICAgICBwZW5kaW5nOiAwLFxuICAgICAgICBza2lwcGVkOiAwLFxuICAgICAgICBmYWlsdXJlczogMSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcbiAgICAgICAgZW5kZWRBdDogZW5kLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgIH0sXG4gICAgICByZXBvcnRlcjogXCJzcGVjXCIsXG4gICAgICByZXBvcnRlclN0YXRzOiB7fSxcbiAgICAgIGhvb2tzOiBbXSxcbiAgICAgIGVycm9yLFxuICAgICAgdmlkZW86IG51bGwsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIG5hbWU6IHMsXG4gICAgICAgIHJlbGF0aXZlOiBzLFxuICAgICAgICBhYnNvbHV0ZTogcyxcbiAgICAgICAgcmVsYXRpdmVUb0NvbW1vblJvb3Q6IHMsXG4gICAgICB9LFxuICAgICAgdGVzdHM6IFtnZXREdW1teUZhaWxlZFRlc3Qoc3RhcnQsIGVycm9yKV0sXG4gICAgICBzaG91bGRVcGxvYWRWaWRlbzogZmFsc2UsXG4gICAgICBza2lwcGVkU3BlYzogZmFsc2UsXG4gICAgfSkpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMoXG4gIHNwZWM6IHN0cmluZyxcbiAgY3lwcmVzc1Jlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgfCB1bmRlZmluZWQge1xuICBpZiAoIWlzU3VjY2Vzc1Jlc3VsdChjeXByZXNzUmVzdWx0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJ1biA9IGN5cHJlc3NSZXN1bHQucnVucy5maW5kKChyKSA9PiByLnNwZWMucmVsYXRpdmUgPT09IHNwZWMpO1xuICBpZiAoIXJ1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0cyA9IGdldFN0YXRzKHJ1bi5zdGF0cyk7XG4gIC8vIGFkanVzdCB0aGUgcmVzdWx0IGZvciBzaW5nZSBzcGVjXG4gIHJldHVybiB7XG4gICAgLi4uY3lwcmVzc1Jlc3VsdCxcbiAgICBydW5zOiBbcnVuXSxcbiAgICB0b3RhbFN1aXRlczogMSxcbiAgICB0b3RhbER1cmF0aW9uOiBzdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICB0b3RhbFRlc3RzOiBzdGF0cy50ZXN0cyxcbiAgICB0b3RhbEZhaWxlZDogc3RhdHMuZmFpbHVyZXMsXG4gICAgdG90YWxQYXNzZWQ6IHN0YXRzLnBhc3NlcyxcbiAgICB0b3RhbFBlbmRpbmc6IHN0YXRzLnBlbmRpbmcsXG4gICAgdG90YWxTa2lwcGVkOiBzdGF0cy5za2lwcGVkLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZW5kZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICB9O1xufVxuIiwgImltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNUyBmcm9tIFwicHJldHR5LW1zXCI7XG5pbXBvcnQgeyB0YWJsZSB9IGZyb20gXCJ0YWJsZVwiO1xuaW1wb3J0IHsgY3lhbiwgZ3JheSwgZ3JlZW4sIHJlZCwgd2hpdGUgfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGZhaWx1cmVJY29uID0gcmVkKFwiXHUyNzE2XCIpO1xuY29uc3Qgc3VjY2Vzc0ljb24gPSBncmVlbihcIlx1MjcxNFwiKTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcnlUYWJsZSA9IChyOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCkgPT4ge1xuICBjb25zdCBvdmVyYWxsU3BlY0NvdW50ID0gci5ydW5zLmxlbmd0aDtcbiAgY29uc3QgZmFpbGVkU3BlY3NDb3VudCA9IF8uc3VtKFxuICAgIHIucnVucy5maWx0ZXIoKHYpID0+IHYuc3RhdHMuZmFpbHVyZXMgKyB2LnN0YXRzLnNraXBwZWQgPiAwKS5tYXAoKCkgPT4gMSlcbiAgKTtcbiAgY29uc3QgaGFzRmFpbGVkID0gZmFpbGVkU3BlY3NDb3VudCA+IDA7XG5cbiAgY29uc3QgdmVyZGljdCA9IGhhc0ZhaWxlZFxuICAgID8gcmVkKGAke2ZhaWxlZFNwZWNzQ291bnR9IG9mICR7b3ZlcmFsbFNwZWNDb3VudH0gZmFpbGVkYClcbiAgICA6IG92ZXJhbGxTcGVjQ291bnQgPiAwXG4gICAgPyBcIkFsbCBzcGVjcyBwYXNzZWQhXCJcbiAgICA6IFwiTm8gc3BlY3MgZXhlY3V0ZWRcIjtcblxuICBjb25zdCBkYXRhID0gci5ydW5zLm1hcCgocikgPT4gW1xuICAgIHIuc3RhdHMuZmFpbHVyZXMgKyByLnN0YXRzLnNraXBwZWQgPiAwID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbixcbiAgICByLnNwZWMucmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgZ3JheShwcmV0dHlNUyhyLnN0YXRzLmR1cmF0aW9uKSksXG4gICAgd2hpdGUoci5zdGF0cy50ZXN0cyA/PyAwKSxcbiAgICByLnN0YXRzLnBhc3NlcyA/IGdyZWVuKHIuc3RhdHMucGFzc2VzKSA6IGdyYXkoXCItXCIpLFxuICAgIHIuc3RhdHMuZmFpbHVyZXMgPyByZWQoci5zdGF0cy5mYWlsdXJlcykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnBlbmRpbmcgPyBjeWFuKHIuc3RhdHMucGVuZGluZykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnNraXBwZWQgPyByZWQoci5zdGF0cy5za2lwcGVkKSA6IGdyYXkoXCItXCIpLFxuICBdKTtcblxuICByZXR1cm4gdGFibGUoXG4gICAgW1xuICAgICAgW1xuICAgICAgICBcIlwiLCAvLyBtYXJrZXJcbiAgICAgICAgZ3JheShcIlNwZWNcIiksXG4gICAgICAgIFwiXCIsXG4gICAgICAgIGdyYXkoXCJUZXN0c1wiKSxcbiAgICAgICAgZ3JheShcIlBhc3NpbmdcIiksXG4gICAgICAgIGdyYXkoXCJGYWlsaW5nXCIpLFxuICAgICAgICBncmF5KFwiUGVuZGluZ1wiKSxcbiAgICAgICAgZ3JheShcIlNraXBwZWRcIiksXG4gICAgICBdLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIFtcbiAgICAgICAgaGFzRmFpbGVkID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbiwgLy8gbWFya2VyXG4gICAgICAgIHZlcmRpY3QsXG4gICAgICAgIGdyYXkocHJldHR5TVMoci50b3RhbER1cmF0aW9uID8/IDApKSxcbiAgICAgICAgb3ZlcmFsbFNwZWNDb3VudCA+IDAgPyB3aGl0ZShyLnRvdGFsVGVzdHMgPz8gMCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBhc3NlZCA/IGdyZWVuKHIudG90YWxQYXNzZWQpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxGYWlsZWQgPyByZWQoci50b3RhbEZhaWxlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBlbmRpbmcgPyBjeWFuKHIudG90YWxQZW5kaW5nKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsU2tpcHBlZCA/IHJlZChyLnRvdGFsU2tpcHBlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgIF0sXG4gICAgXSxcbiAgICB7XG4gICAgICBib3JkZXIsXG4gICAgICBjb2x1bW5EZWZhdWx0OiB7XG4gICAgICAgIHdpZHRoOiA4LFxuICAgICAgfSxcbiAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwibGVmdFwiLCB3aWR0aDogMiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJsZWZ0XCIsIHdpZHRoOiAzMCB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgXSxcbiAgICAgIC8vIHNpbmdsZUxpbmU6IHRydWUsXG4gICAgICBkcmF3SG9yaXpvbnRhbExpbmU6IChsaW5lSW5kZXgsIHJvd0NvdW50KSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbGluZUluZGV4ID09PSAxIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSAwIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSByb3dDb3VudCAtIDEgfHxcbiAgICAgICAgICBsaW5lSW5kZXggPT09IHJvd0NvdW50XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZHJhd1ZlcnRpY2FsTGluZTogKGxpbmVJbmRleCwgcm93Q291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gMCB8fCByb3dDb3VudCA9PT0gbGluZUluZGV4O1xuICAgICAgfSxcbiAgICB9XG4gICk7XG59O1xuXG5jb25zdCBib3JkZXIgPSBfLm1hcFZhbHVlcyhcbiAge1xuICAgIHRvcEJvZHk6IGBcdTI1MDBgLFxuICAgIHRvcEpvaW46IGBcdTI1MkNgLFxuICAgIHRvcExlZnQ6IGAgIFx1MjUwQ2AsXG4gICAgdG9wUmlnaHQ6IGBcdTI1MTBgLFxuXG4gICAgYm90dG9tQm9keTogYFx1MjUwMGAsXG4gICAgYm90dG9tSm9pbjogYFx1MjUzNGAsXG4gICAgYm90dG9tTGVmdDogYCAgXHUyNTE0YCxcbiAgICBib3R0b21SaWdodDogYFx1MjUxOGAsXG5cbiAgICBib2R5TGVmdDogYCAgXHUyNTAyYCxcbiAgICBib2R5UmlnaHQ6IGBcdTI1MDJgLFxuICAgIGJvZHlKb2luOiBgXHUyNTAyYCxcblxuICAgIGpvaW5Cb2R5OiBgXHUyNTAwYCxcbiAgICBqb2luTGVmdDogYCAgXHUyNTFDYCxcbiAgICBqb2luUmlnaHQ6IGBcdTI1MjRgLFxuICAgIGpvaW5Kb2luOiBgXHUyNTNDYCxcbiAgfSxcbiAgKHYpID0+IGdyYXkodilcbik7XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHtcbiAgcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkLFxuICBzZXRJbnN0YW5jZVRlc3RzLFxuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgdXBkYXRlSW5zdGFuY2VSZXN1bHRzLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyB1cGxvYWRBcnRpZmFjdHMsIHVwbG9hZFN0ZG91dFNhZmUgfSBmcm9tIFwiLi4vYXJ0aWZhY3RzXCI7XG5pbXBvcnQgeyBzZXRDYW5jZWxsYXRpb25SZWFzb24gfSBmcm9tIFwiLi4vY2FuY2VsbGF0aW9uXCI7XG5pbXBvcnQgeyBnZXRJbml0aWFsT3V0cHV0IH0gZnJvbSBcIi4uL2NhcHR1cmVcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi4vZW52XCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcbmltcG9ydCB7IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZCwgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgfSBmcm9tIFwiLi9yZXN1bHRzXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cmVzdWx0c1wiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlcG9ydFJlc3VsdHNUYXNrKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBzdGRvdXQ6IHN0cmluZyxcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBleGVjdXRpb25TdGF0ZS5nZXRJbnN0YW5jZVJlc3VsdHMoY29uZmlnU3RhdGUsIGluc3RhbmNlSWQpO1xuICBjb25zdCBydW4gPSByZXN1bHRzLnJ1bnNbMF07XG4gIGlmICghcnVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcnVuIGZvdW5kIGluIEN5cHJlc3MgcmVzdWx0c1wiKTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZVJlc3VsdHMgPSBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQocnVuLCBjb3ZlcmFnZUZpbGVQYXRoKTtcbiAgY29uc3QgaW5zdGFuY2VUZXN0cyA9IGdldEluc3RhbmNlVGVzdHNQYXlsb2FkKHJ1biwgcmVzdWx0cy5jb25maWcpO1xuICBjb25zdCB7IHZpZGVvVXBsb2FkVXJsLCBzY3JlZW5zaG90VXBsb2FkVXJscywgY292ZXJhZ2VVcGxvYWRVcmwsIGNsb3VkIH0gPVxuICAgIGF3YWl0IHJlcG9ydFJlc3VsdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VUZXN0cywgaW5zdGFuY2VSZXN1bHRzKTtcblxuICBpZiAoY2xvdWQ/LnNob3VsZENhbmNlbCkge1xuICAgIGRlYnVnKFwiaW5zdGFuY2UgJXMgc2hvdWxkIGNhbmNlbFwiLCBpbnN0YW5jZUlkKTtcbiAgICBzZXRDYW5jZWxsYXRpb25SZWFzb24oY2xvdWQuc2hvdWxkQ2FuY2VsKTtcbiAgfVxuXG4gIGRlYnVnKFwiaW5zdGFuY2UgJXMgYXJ0aWZhY3QgdXBsb2FkIGluc3RydWN0aW9ucyAlb1wiLCBpbnN0YW5jZUlkLCB7XG4gICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gICAgY292ZXJhZ2VVcGxvYWRVcmwsXG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgdXBsb2FkQXJ0aWZhY3RzKHtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgICB2aWRlb1BhdGg6IHJ1bi52aWRlbyxcbiAgICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICAgICAgc2NyZWVuc2hvdHM6IGluc3RhbmNlUmVzdWx0cy5zY3JlZW5zaG90cyxcbiAgICAgIGNvdmVyYWdlVXBsb2FkVXJsLFxuICAgICAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgICB9KSxcbiAgICB1cGxvYWRTdGRvdXRTYWZlKGluc3RhbmNlSWQsIGdldEluaXRpYWxPdXRwdXQoKSArIHN0ZG91dCksXG4gIF0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXBvcnRSZXN1bHRzKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIGluc3RhbmNlVGVzdHM6IFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBpbnN0YW5jZVJlc3VsdHM6IFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWRcbikge1xuICBkZWJ1ZyhcInJlcG9ydGluZyBpbnN0YW5jZSAlcyByZXN1bHRzLi4uXCIsIGluc3RhbmNlSWQpO1xuICBpZiAoaXNDdXJyZW50cygpKSB7XG4gICAgcmV0dXJuIHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZChpbnN0YW5jZUlkLCB7XG4gICAgICB0ZXN0czogaW5zdGFuY2VUZXN0cyxcbiAgICAgIHJlc3VsdHM6IGluc3RhbmNlUmVzdWx0cyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJ1biBvbmUgYWZ0ZXIgYW5vdGhlclxuICBhd2FpdCBzZXRJbnN0YW5jZVRlc3RzKGluc3RhbmNlSWQsIGluc3RhbmNlVGVzdHMpO1xuICByZXR1cm4gdXBkYXRlSW5zdGFuY2VSZXN1bHRzKGluc3RhbmNlSWQsIGluc3RhbmNlUmVzdWx0cyk7XG59XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgU2NyZWVuc2hvdEFydGlmYWN0LCBTY3JlZW5zaG90VXBsb2FkSW5zdHJ1Y3Rpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHVwZGF0ZUluc3RhbmNlU3Rkb3V0IH0gZnJvbSBcIi4vYXBpXCI7XG5pbXBvcnQgeyBzYWZlIH0gZnJvbSBcIi4vbGFuZ1wiO1xuaW1wb3J0IHsgZGltIH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQgeyBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XG5pbXBvcnQgeyB1cGxvYWRJbWFnZSwgdXBsb2FkSnNvbiwgdXBsb2FkVmlkZW8gfSBmcm9tIFwiLi91cGxvYWRcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czphcnRpZmFjdHNcIik7XG5pbnRlcmZhY2UgVXBsb2FkQXJ0aWZhY3RzIHtcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlO1xuICB2aWRlb1BhdGg6IHN0cmluZyB8IG51bGw7XG4gIHZpZGVvVXBsb2FkVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgc2NyZWVuc2hvdHM6IFNjcmVlbnNob3RBcnRpZmFjdFtdO1xuICBzY3JlZW5zaG90VXBsb2FkVXJsczogU2NyZWVuc2hvdFVwbG9hZEluc3RydWN0aW9uW107XG4gIGNvdmVyYWdlVXBsb2FkVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZyB8IG51bGw7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXJ0aWZhY3RzKHtcbiAgZXhlY3V0aW9uU3RhdGUsXG4gIHZpZGVvUGF0aCxcbiAgdmlkZW9VcGxvYWRVcmwsXG4gIHNjcmVlbnNob3RzLFxuICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgY292ZXJhZ2VVcGxvYWRVcmwsXG59OiBVcGxvYWRBcnRpZmFjdHMpIHtcbiAgZGVidWcoXCJ1cGxvYWRpbmcgYXJ0aWZhY3RzOiAlb1wiLCB7XG4gICAgdmlkZW9QYXRoLFxuICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgIHNjcmVlbnNob3RzLFxuICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICAgIGNvdmVyYWdlRmlsZVBhdGgsXG4gICAgY292ZXJhZ2VVcGxvYWRVcmwsXG4gIH0pO1xuXG4gIGNvbnN0IHRvdGFsVXBsb2FkcyA9XG4gICAgKHZpZGVvUGF0aCA/IDEgOiAwKSArIHNjcmVlbnNob3RzLmxlbmd0aCArIChjb3ZlcmFnZVVwbG9hZFVybCA/IDEgOiAwKTtcbiAgaWYgKHRvdGFsVXBsb2FkcyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVwbG9hZCB2aWRlb1xuICBpZiAodmlkZW9VcGxvYWRVcmwgJiYgdmlkZW9QYXRoKSB7XG4gICAgYXdhaXQgc2FmZShcbiAgICAgIHVwbG9hZFZpZGVvLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZGVidWcoXCJmYWlsZWQgdXBsb2FkaW5nIHZpZGVvICVzLiBFcnJvcjogJW9cIiwgdmlkZW9QYXRoLCBlKTtcbiAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICBgRmFpbGVkIHVwbG9hZGluZyB2aWRlbyAke3ZpZGVvUGF0aH0uXFxuJHtkaW0oZSl9YFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgdmlkZW9QYXRoKVxuICAgICkodmlkZW9QYXRoLCB2aWRlb1VwbG9hZFVybCk7XG4gIH1cbiAgLy8gdXBsb2FkIHNjcmVlbnNob3RzXG4gIGlmIChzY3JlZW5zaG90VXBsb2FkVXJscyAmJiBzY3JlZW5zaG90VXBsb2FkVXJscy5sZW5ndGgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNjcmVlbnNob3RzLm1hcCgoc2NyZWVuc2hvdCkgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBzY3JlZW5zaG90VXBsb2FkVXJscy5maW5kKFxuICAgICAgICAgICh1cmxzKSA9PiB1cmxzLnNjcmVlbnNob3RJZCA9PT0gc2NyZWVuc2hvdC5zY3JlZW5zaG90SWRcbiAgICAgICAgKT8udXBsb2FkVXJsO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgXCJObyB1cGxvYWQgdXJsIGZvciBzY3JlZW5zaG90ICVvLCBzY3JlZW5zaG90VXBsb2FkVXJsczogJW9cIixcbiAgICAgICAgICAgIHNjcmVlbnNob3QsXG4gICAgICAgICAgICBzY3JlZW5zaG90VXBsb2FkVXJsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgIGBObyB1cGxvYWQgVVJMIGZvciBzY3JlZW5zaG90ICR7c2NyZWVuc2hvdC5wYXRofWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZShcbiAgICAgICAgICB1cGxvYWRJbWFnZSxcbiAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgIFwiZmFpbGVkIHVwbG9hZGluZyBzY3JlZW5zaG90ICVzLiBFcnJvcjogJW9cIixcbiAgICAgICAgICAgICAgc2NyZWVuc2hvdC5wYXRoLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgICAgYEZhaWxlZCB1cGxvYWRpbmcgc2NyZWVuc2hvdCAke3NjcmVlbnNob3QucGF0aH0uXFxuJHtkaW0oZSl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgc2NyZWVuc2hvdC5wYXRoKVxuICAgICAgICApKHNjcmVlbnNob3QucGF0aCwgdXJsKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvLyB1cGxvYWQgY292ZXJhZ2VcbiAgaWYgKGNvdmVyYWdlVXBsb2FkVXJsICYmIGNvdmVyYWdlRmlsZVBhdGgpIHtcbiAgICBhd2FpdCBzYWZlKFxuICAgICAgdXBsb2FkSnNvbixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIFwiZmFpbGVkIHVwbG9hZGluZyBjb3ZlcmFnZSBmaWxlICVzLiBFcnJvcjogJW9cIixcbiAgICAgICAgICBjb3ZlcmFnZUZpbGVQYXRoLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcblxuICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgIGBGYWlsZWQgdXBsb2FkaW5nIGNvdmVyYWdlIGZpbGUgJHtjb3ZlcmFnZUZpbGVQYXRofS5cXG4ke2RpbShlKX1gXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIGNvdmVyYWdlRmlsZVBhdGgpXG4gICAgKShjb3ZlcmFnZUZpbGVQYXRoLCBjb3ZlcmFnZVVwbG9hZFVybCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwbG9hZFN0ZG91dFNhZmUgPSBzYWZlKFxuICB1cGRhdGVJbnN0YW5jZVN0ZG91dCxcbiAgKCkgPT4ge30sXG4gICgpID0+IHt9XG4pO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IG1ha2VSZXF1ZXN0IH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuY29uc3QgcmVhZEZpbGUgPSBmcy5wcm9taXNlcy5yZWFkRmlsZTtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp1cGxvYWRcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRWaWRlbyhmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJ2aWRlby9tcDRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRJbWFnZShmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJpbWFnZS9wbmdcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRKc29uKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG59XG5cbnR5cGUgVXBsb2FkVHlwZXMgPVxuICB8IFwidmlkZW8vbXA0XCJcbiAgfCBcImltYWdlL3BuZ1wiXG4gIHwgXCJwbGFpbi90ZXh0XCJcbiAgfCBcImFwcGxpY2F0aW9uL2pzb25cIjtcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgdHlwZTogVXBsb2FkVHlwZXMpIHtcbiAgZGVidWcoJ3VwbG9hZGluZyBmaWxlIFwiJXNcIiB0byBcIiVzXCInLCBmaWxlLCB1cmwpO1xuICBjb25zdCBmID0gYXdhaXQgcmVhZEZpbGUoZmlsZSk7XG4gIGF3YWl0IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIGRhdGE6IGYsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogdHlwZSxcbiAgICAgIFwiQ29udGVudC1EaXNwb3NpdGlvblwiOiBgaW5saW5lYCxcbiAgICB9LFxuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBFdmVudCwgcHVic3ViIH0gZnJvbSBcIi4uL3B1YnN1YlwiO1xuXG5pbnRlcmZhY2UgRXhlY3V0aW9uU3RhdGUge1xuICBjYW5jZWxsYXRpb25SZWFzb246IHN0cmluZyB8IG51bGw7XG59XG5jb25zdCBzdGF0ZTogRXhlY3V0aW9uU3RhdGUgPSB7XG4gIGNhbmNlbGxhdGlvblJlYXNvbjogbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRDYW5jZWxsYXRpb25SZWFzb24gPSAocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgaWYgKHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb24gPSByZWFzb247XG4gIHB1YnN1Yi5lbWl0KEV2ZW50LlJVTl9DQU5DRUxMRUQsIHJlYXNvbik7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FuY2VsbGF0aW9uUmVhc29uID0gKCkgPT4gc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uO1xuIiwgImltcG9ydCB7XG4gIFNwZWNXaXRoUmVsYXRpdmVSb290LFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRDYXB0dXJlZE91dHB1dCwgcmVzZXRDYXB0dXJlIH0gZnJvbSBcIi4uL2NhcHR1cmVcIjtcblxuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQge1xuICBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzLFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkLFxuICBJbnN0YW5jZVJlc3BvbnNlU3BlY0RldGFpbHMsXG59IGZyb20gXCIuLi9hcGlcIjtcblxuaW1wb3J0IHsgcnVuU3BlY0ZpbGVTYWZlIH0gZnJvbSBcIi4uL2N5cHJlc3NcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi4vZW52XCI7XG5pbXBvcnQgeyBkaXZpZGVyLCBpbmZvLCB0aXRsZSwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgY3JlYXRlUmVwb3J0VGFzaywgcmVwb3J0VGFza3MgfSBmcm9tIFwiLi9yZXBvcnRUYXNrXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpydW5uZXJcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5UaWxsRG9uZShcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHtcbiAgICBydW5JZCxcbiAgICBncm91cElkLFxuICAgIG1hY2hpbmVJZCxcbiAgICBwbGF0Zm9ybSxcbiAgICBzcGVjczogYWxsU3BlY3MsXG4gIH06IENyZWF0ZUluc3RhbmNlUGF5bG9hZCAmIHtcbiAgICBzcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXTtcbiAgfSxcbiAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnNcbikge1xuICBsZXQgaGFzTW9yZSA9IHRydWU7XG5cbiAgd2hpbGUgKGhhc01vcmUpIHtcbiAgICBjb25zdCBuZXdUYXNrcyA9IGF3YWl0IHJ1bkJhdGNoKGV4ZWN1dGlvblN0YXRlLCBjb25maWdTdGF0ZSwge1xuICAgICAgcnVuTWV0YToge1xuICAgICAgICBydW5JZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgbWFjaGluZUlkLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgIH0sXG4gICAgICBhbGxTcGVjcyxcbiAgICAgIHBhcmFtcyxcbiAgICB9KTtcbiAgICBpZiAoIW5ld1Rhc2tzLmxlbmd0aCkge1xuICAgICAgZGVidWcoXCJObyBtb3JlIHRhc2tzIHRvIHJ1bi4gVXBsb2FkcyBxdWV1ZTogJWRcIiwgcmVwb3J0VGFza3MubGVuZ3RoKTtcbiAgICAgIGhhc01vcmUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuZXdUYXNrcy5mb3JFYWNoKCh0KSA9PlxuICAgICAgY3JlYXRlUmVwb3J0VGFzayhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIHQuaW5zdGFuY2VJZClcbiAgICApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkJhdGNoKFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHJ1bk1ldGEsXG4gICAgcGFyYW1zLFxuICAgIGFsbFNwZWNzLFxuICB9OiB7XG4gICAgcnVuTWV0YToge1xuICAgICAgcnVuSWQ6IHN0cmluZztcbiAgICAgIGdyb3VwSWQ6IHN0cmluZztcbiAgICAgIG1hY2hpbmVJZDogc3RyaW5nO1xuICAgICAgcGxhdGZvcm06IENyZWF0ZUluc3RhbmNlUGF5bG9hZFtcInBsYXRmb3JtXCJdO1xuICAgIH07XG4gICAgYWxsU3BlY3M6IFNwZWNXaXRoUmVsYXRpdmVSb290W107XG4gICAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG4gIH1cbikge1xuICBsZXQgYmF0Y2ggPSB7XG4gICAgc3BlY3M6IFtdIGFzIEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlsc1tdLFxuICAgIGNsYWltZWRJbnN0YW5jZXM6IDAsXG4gICAgdG90YWxJbnN0YW5jZXM6IDAsXG4gIH07XG5cbiAgaWYgKGlzQ3VycmVudHMoKSkge1xuICAgIGRlYnVnKFwiR2V0dGluZyBiYXRjaGVkIHRhc2tzOiAlZFwiLCBwYXJhbXMuYmF0Y2hTaXplKTtcbiAgICBiYXRjaCA9IGF3YWl0IGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMoe1xuICAgICAgLi4ucnVuTWV0YSxcbiAgICAgIGJhdGNoU2l6ZTogcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICB9KTtcbiAgICBkZWJ1ZyhcIkdvdCBiYXRjaGVkIHRhc2tzOiAlb1wiLCBiYXRjaCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVJbnN0YW5jZShydW5NZXRhKTtcblxuICAgIGlmIChyZXNwb25zZS5zcGVjICE9PSBudWxsICYmIHJlc3BvbnNlLmluc3RhbmNlSWQgIT09IG51bGwpIHtcbiAgICAgIGJhdGNoLnNwZWNzLnB1c2goe1xuICAgICAgICBzcGVjOiByZXNwb25zZS5zcGVjLFxuICAgICAgICBpbnN0YW5jZUlkOiByZXNwb25zZS5pbnN0YW5jZUlkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoLmNsYWltZWRJbnN0YW5jZXMgPSByZXNwb25zZS5jbGFpbWVkSW5zdGFuY2VzO1xuICAgIGJhdGNoLnRvdGFsSW5zdGFuY2VzID0gcmVzcG9uc2UudG90YWxJbnN0YW5jZXM7XG4gIH1cblxuICBpZiAoYmF0Y2guc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhdGNoIGNhbiBoYXZlIG11bHRpcGxlIHNwZWNzLiBXaGlsZSBydW5uaW5nIHRoZSBzcGVjcyxcbiAgICogY3lwcmVzcyBjYW4gaGFyZC1jcmFzaCB3aXRob3V0IHJlcG9ydGluZyBhbnkgcmVzdWx0LlxuICAgKlxuICAgKiBXaGVuIGNyYXNoZWQsIGlkZWFsbHksIHdlIG5lZWQgdG86XG4gICAqIC0gZGV0ZXJtaW5lIHdoaWNoIHNwZWMgY3Jhc2hlZFxuICAgKiAtIGFzc29jaWF0ZSB0aGUgY3Jhc2ggd2l0aCB0aGUgc3BlY1xuICAgKiAtIHJ1biB0aGUgcmVzdCBvZiB1bnJlcG9ydGVkIHNwZWNzIGluIHRoZSBiYXRjaFxuICAgKlxuICAgKiBCdXQgZGV0ZWN0aW5nIHRoZSBjcmFzaGVkIHNwZWMgaXMgZXJyb3ItcHJvbmUgYW5kIGluYWNjdXJhdGUsXG4gICAqIHNvIHdlIGZhbGwgYmFjayB0byByZXBvcnRpbmcgaGFyZCBjcmFzaCB0byBhbGwgc3Vic2VxdWVudFxuICAgKiBzcGVjcyBpbiB0aGUgYmF0Y2guXG4gICAqXG4gICAqIFdvcnN0LWNhc2Ugc2NlbmFyaW86IHdlIHJlcG9ydCBoYXJkIGNyYXNoIHRvIGFsbCBzcGVjcyBpbiB0aGUgYmF0Y2guXG4gICAqL1xuXG4gIC8vICVzdGF0ZVxuICBiYXRjaC5zcGVjcy5mb3JFYWNoKChpKSA9PiBleGVjdXRpb25TdGF0ZS5pbml0SW5zdGFuY2UoaSkpO1xuXG4gIGRpdmlkZXIoKTtcbiAgaW5mbyhcbiAgICBcIlJ1bm5pbmc6ICVzICglZC8lZClcIixcbiAgICBiYXRjaC5zcGVjcy5tYXAoKHMpID0+IHMuc3BlYykuam9pbihcIiwgXCIpLFxuICAgIGJhdGNoLmNsYWltZWRJbnN0YW5jZXMsXG4gICAgYmF0Y2gudG90YWxJbnN0YW5jZXNcbiAgKTtcblxuICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCBydW5TcGVjRmlsZVNhZmUoXG4gICAge1xuICAgICAgLy8gdXNlIGFic29sdXRlIHBhdGhzIC0gdXNlciBjYW4gcnVuIHRoZSBwcm9ncmFtIGZyb20gYSBkaWZmZXJlbnQgZGlyZWN0b3J5LCBlLmcuIG54IG9yIGEgbW9ub3JlcG8gd29ya3NwYWNlXG4gICAgICAvLyBjeXByZXNzIHN0aWxsIHJlcG9ydCB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgcHJvamVjdCByb290XG4gICAgICBzcGVjOiBiYXRjaC5zcGVjc1xuICAgICAgICAubWFwKChicykgPT4gZ2V0U3BlY0Fic29sdXRlUGF0aChhbGxTcGVjcywgYnMuc3BlYykpXG4gICAgICAgIC5qb2luKFwiLFwiKSxcbiAgICB9LFxuICAgIHBhcmFtc1xuICApO1xuXG4gIHRpdGxlKFwiYmx1ZVwiLCBcIlJlcG9ydGluZyByZXN1bHRzIGFuZCBhcnRpZmFjdHMgaW4gYmFja2dyb3VuZC4uLlwiKTtcblxuICBjb25zdCBvdXRwdXQgPSBnZXRDYXB0dXJlZE91dHB1dCgpO1xuXG4gIC8vICVzdGF0ZVxuICBiYXRjaC5zcGVjcy5mb3JFYWNoKChzcGVjKSA9PiB7XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0SW5zdGFuY2VPdXRwdXQoc3BlYy5pbnN0YW5jZUlkLCBvdXRwdXQpO1xuICAgIGNvbnN0IHNwZWNSdW5SZXN1bHQgPSBnZXRDeXByZXNzUnVuUmVzdWx0Rm9yU3BlYyhzcGVjLnNwZWMsIHJhd1Jlc3VsdCk7XG4gICAgaWYgKCFzcGVjUnVuUmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV4ZWN1dGlvblN0YXRlLnNldEluc3RhbmNlUmVzdWx0KFxuICAgICAgY29uZmlnU3RhdGUsXG4gICAgICBzcGVjLmluc3RhbmNlSWQsXG4gICAgICBzcGVjUnVuUmVzdWx0XG4gICAgKTtcbiAgfSk7XG5cbiAgcmVzZXRDYXB0dXJlKCk7XG5cbiAgcmV0dXJuIGJhdGNoLnNwZWNzO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjQWJzb2x1dGVQYXRoKFxuICBhbGxTcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXSxcbiAgcmVsYXRpdmU6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IGFic29sdXRlUGF0aCA9IGFsbFNwZWNzLmZpbmQoKGkpID0+IGkucmVsYXRpdmUgPT09IHJlbGF0aXZlKT8uYWJzb2x1dGU7XG4gIGlmICghYWJzb2x1dGVQYXRoKSB7XG4gICAgd2FybihcbiAgICAgICdDYW5ub3QgZmluZCBhYnNvbHV0ZSBwYXRoIGZvciBzcGVjLiBTcGVjOiBcIiVzXCIsIGNhbmRpZGF0ZXM6ICVvJyxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgYWxsU3BlY3NcbiAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYWJzb2x1dGUgcGF0aCBmb3Igc3BlY2ApO1xuICB9XG4gIHJldHVybiBhYnNvbHV0ZVBhdGg7XG59XG4iLCAiaW1wb3J0IHsgSW5zdGFuY2VJZCB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldFJlcG9ydFJlc3VsdHNUYXNrIH0gZnJvbSBcIi4uL3Jlc3VsdHNcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cmVwb3J0VGFza1wiKTtcblxuZXhwb3J0IGNvbnN0IHJlcG9ydFRhc2tzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVwb3J0VGFzayA9IChcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGluc3RhbmNlSWQ6IEluc3RhbmNlSWRcbikgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IGV4ZWN1dGlvblN0YXRlLmdldEluc3RhbmNlKGluc3RhbmNlSWQpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgZXJyb3IoXCJDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlICVzXCIsIGluc3RhbmNlSWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5zdGFuY2UucmVwb3J0U3RhcnRlZEF0KSB7XG4gICAgZGVidWcoXCJSZXBvcnQgdGFzayBhbHJlYWR5IGNyZWF0ZWQgZm9yIGluc3RhbmNlICVzXCIsIGluc3RhbmNlSWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGluc3RhbmNlLnJlcG9ydFN0YXJ0ZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgZGVidWcoXCJDcmVhdGluZyByZXBvcnQgdGFzayBmb3IgaW5zdGFuY2VJZCAlc1wiLCBpbnN0YW5jZUlkKTtcbiAgcmVwb3J0VGFza3MucHVzaChcbiAgICBnZXRSZXBvcnRSZXN1bHRzVGFzayhcbiAgICAgIGluc3RhbmNlSWQsXG4gICAgICBjb25maWdTdGF0ZSxcbiAgICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgICAgaW5zdGFuY2Uub3V0cHV0ID8/IFwibm8gb3V0cHV0IGNhcHR1cmVkXCIsXG4gICAgICBpbnN0YW5jZS5jb3ZlcmFnZUZpbGVQYXRoXG4gICAgKS5jYXRjaChlcnJvcilcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXBvcnRUYXNrU3BlYyA9IChcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIHNwZWM6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IGkgPSBleGVjdXRpb25TdGF0ZS5nZXRTcGVjKHNwZWMpO1xuICBpZiAoIWkpIHtcbiAgICBlcnJvcihcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyAlc1wiLCBzcGVjKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVidWcoXCJDcmVhdGluZyByZXBvcnQgdGFzayBmb3Igc3BlYyAlc1wiLCBzcGVjKTtcbiAgcmV0dXJuIGNyZWF0ZVJlcG9ydFRhc2soY29uZmlnU3RhdGUsIGV4ZWN1dGlvblN0YXRlLCBpLmluc3RhbmNlSWQpO1xufTtcbiIsICJpbXBvcnQgeyBCUHJvbWlzZSB9IGZyb20gXCIuLi9sYW5nXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgRXZlbnQsIHB1YnN1YiB9IGZyb20gXCIuLi9wdWJzdWJcIjtcbmltcG9ydCB7IHJ1blRpbGxEb25lIH0gZnJvbSBcIi4vcnVubmVyXCI7XG5cbmxldCBjYW5jZWxsYWJsZToge1xuICBjYW5jZWw6ICgpID0+IHZvaWQ7XG59IHwgbnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIG9uUnVuQ2FuY2VsbGVkKHJlYXNvbjogc3RyaW5nKSB7XG4gIHdhcm4oXG4gICAgYFJ1biBjYW5jZWxsZWQ6ICVzLiBXYWl0aW5nIGZvciB1cGxvYWRzIHRvIGNvbXBsZXRlIGFuZCBzdG9wcGluZyBleGVjdXRpb24uLi5gLFxuICAgIHJlYXNvblxuICApO1xuICBjYW5jZWxsYWJsZT8uY2FuY2VsKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVGlsbERvbmVPckNhbmNlbGxlZChcbiAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgcnVuVGlsbERvbmU+XG4pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgIGNhbmNlbGxhYmxlID0gbmV3IEJQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICBpZiAoIW9uQ2FuY2VsKSB7XG4gICAgICAgIF9yZWplY3QobmV3IEVycm9yKFwiQmx1ZUJpcmQgaXMgbWlzY29uZmlndXJlZDogb25DYW5jZWwgaXMgdW5kZWZpbmVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25DYW5jZWwoKCkgPT4gX3Jlc29sdmUodm9pZCAwKSk7XG4gICAgICBydW5UaWxsRG9uZSguLi5hcmdzKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIF9yZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIF9yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcHVic3ViLmFkZExpc3RlbmVyKEV2ZW50LlJVTl9DQU5DRUxMRUQsIG9uUnVuQ2FuY2VsbGVkKTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgcHVic3ViLnJlbW92ZUxpc3RlbmVyKEV2ZW50LlJVTl9DQU5DRUxMRUQsIG9uUnVuQ2FuY2VsbGVkKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgc3RvcFdTUyB9IGZyb20gXCIuL3dzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaHV0ZG93bigpIHtcbiAgYXdhaXQgc3RvcFdTUygpO1xufVxuIiwgIi8qISBAcHJlc2VydmVcblxuIyMjIE1JVFxuXG5QYXJ0cyBvZiB0aGlzIGNvZGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MgYW5kIGlzIHN1YmplY3QgdG8gTUlUIGxpY2Vuc2UuXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAyMiBDeXByZXNzLmlvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbmltcG9ydCBjb21tb25QYXRoUHJlZml4IGZyb20gXCJjb21tb24tcGF0aC1wcmVmaXhcIjtcbmltcG9ydCBnbG9iYnksIHsgR2xvYmJ5T3B0aW9ucyB9IGZyb20gXCJnbG9iYnlcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBvcyBmcm9tIFwib3NcIjtcbmltcG9ydCB7XG4gIEZpbmRTcGVjcyxcbiAgU3BlY1R5cGUsXG4gIFNwZWNXaXRoUmVsYXRpdmVSb290LFxuICBUZXN0aW5nVHlwZSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0b0FycmF5LCB0b1Bvc2l4IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpzcGVjc1wiKTtcblxudHlwZSBHbG9iUGF0dGVybiA9IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4vKipcbiAqIFJlcGxpY2F0ZSBob3cgY3lwcmVzcyBpcyBkaXNjb3ZlcmluZyBzcGVjIGZpbGVzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvYmM5ZWRiNDQ1MjNkNjJjYTkzNDgyN2I4ZTg3MGYzOGY4NjYzNGNhNC9wYWNrYWdlcy9kYXRhLWNvbnRleHQvc3JjL3NvdXJjZXMvUHJvamVjdERhdGFTb3VyY2UudHMjTDI1MFxuICogaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2JjOWVkYjQ0NTIzZDYyY2E5MzQ4MjdiOGU4NzBmMzhmODY2MzRjYTQvcGFja2FnZXMvZGF0YS1jb250ZXh0L3NyYy9hY3Rpb25zL1Byb2plY3RBY3Rpb25zLnRzI0w0MTdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRTcGVjcyh7XG4gIHByb2plY3RSb290LFxuICB0ZXN0aW5nVHlwZSxcbiAgc3BlY1BhdHRlcm4sXG4gIGNvbmZpZ1NwZWNQYXR0ZXJuLFxuICBleGNsdWRlU3BlY1BhdHRlcm4sXG4gIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxufTogRmluZFNwZWNzPHN0cmluZ1tdIHwgc3RyaW5nPik6IFByb21pc2U8U3BlY1dpdGhSZWxhdGl2ZVJvb3RbXT4ge1xuICBjb25maWdTcGVjUGF0dGVybiA9IHRvQXJyYXkoY29uZmlnU3BlY1BhdHRlcm4pO1xuICBzcGVjUGF0dGVybiA9IHRvQXJyYXkoc3BlY1BhdHRlcm4pO1xuICBleGNsdWRlU3BlY1BhdHRlcm4gPSB0b0FycmF5KGV4Y2x1ZGVTcGVjUGF0dGVybikgfHwgW107XG5cbiAgLy8gZXhjbHVkZSBhbGwgc3BlY3MgbWF0Y2hpbmcgZTJlIGlmIGluIGNvbXBvbmVudCB0ZXN0aW5nXG4gIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuID0gdG9BcnJheShhZGRpdGlvbmFsSWdub3JlUGF0dGVybikgfHwgW107XG5cbiAgZGVidWcoXCJleHBsb3Jpbmcgc3BlYyBmaWxlcyBmb3IgZXhlY3V0aW9uICVPXCIsIHtcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBwcm9qZWN0Um9vdCxcbiAgICBzcGVjUGF0dGVybixcbiAgICBjb25maWdTcGVjUGF0dGVybixcbiAgICBleGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gIH0pO1xuXG4gIGlmICghc3BlY1BhdHRlcm4gfHwgIWNvbmZpZ1NwZWNQYXR0ZXJuKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBnbG9iIHBhdHRlcm5zIGZvciBleHBsb3Jpbmcgc3BlY3NcIik7XG4gIH1cblxuICBsZXQgc3BlY0Fic29sdXRlUGF0aHMgPSBhd2FpdCBnZXRGaWxlc0J5R2xvYihwcm9qZWN0Um9vdCwgc3BlY1BhdHRlcm4sIHtcbiAgICBhYnNvbHV0ZTogdHJ1ZSxcbiAgICBpZ25vcmU6IFsuLi5leGNsdWRlU3BlY1BhdHRlcm4sIC4uLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuXSxcbiAgfSk7XG5cbiAgLy8gSWYgdGhlIHNwZWNQYXR0ZXJuIGFuZCBjb25maWdTcGVjUGF0dGVybiBhcmUgZGlmZmVyZW50LFxuICAvLyBpdCBtZWFucyB0aGUgdXNlciBwYXNzZWQgc29tZXRoaW5nIG5vbi1kZWZhdWx0IHZpYSAtLXNwZWMgKHJ1biBtb2RlIG9ubHkpXG4gIC8vIGluIHRoaXMgc2NlbmFyaW8sIHdlIHdhbnQgdG8gZ3JhYiBldmVyeXRoaW5nIHRoYXQgbWF0Y2hlcyBgLS1zcGVjYFxuICAvLyB0aGF0IGZhbGxzIHdpdGhpbiB0aGVpciBkZWZhdWx0IHNwZWNQYXR0ZXJuLiBUaGUgcmVhc29uIGlzIHNvIHdlIGF2b2lkXG4gIC8vIGF0dGVtcHRpbmcgdG8gcnVuIHRoaW5ncyB0aGF0IGFyZSBub3Qgc3BlY3MsIGVnIHNvdXJjZSBjb2RlLCB2aWRlb3MsIGV0Yy5cbiAgLy9cbiAgLy8gRXhhbXBsZTogZGV2ZWxvcGVyIHdhbnRzIHRvIHJ1biB0ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGltZXJzIGluIHBhY2thZ2VzL2RyaXZlclxuICAvLyBTbyB0aGV5IHJ1biB5YXJuIGN5cHJlc3M6cnVuIC0tc3BlYyAqKi90aW1lcnMqXG4gIC8vIHdlIGRvICoqbm90Kiogd2FudCB0byBjYXB0dXJlIGB0aW1lcnMudHNgIChzb3VyY2UgY29kZSkgb3IgYSB2aWRlbyBpblxuICAvLyBjeXByZXNzL3ZpZGVvcy90aW1lcnMuY3kudHMubXA0LCBzbyB3ZSB0YWtlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBzcGVjUGF0dGVyblxuICAvLyBhbmQgLS1zcGVjLlxuICBpZiAoIV8uaXNFcXVhbChzcGVjUGF0dGVybiwgY29uZmlnU3BlY1BhdHRlcm4pKSB7XG4gICAgY29uc3QgZGVmYXVsdFNwZWNBYnNvbHV0ZVBhdGhzID0gYXdhaXQgZ2V0RmlsZXNCeUdsb2IoXG4gICAgICBwcm9qZWN0Um9vdCxcbiAgICAgIGNvbmZpZ1NwZWNQYXR0ZXJuLFxuICAgICAge1xuICAgICAgICBhYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlOiBbLi4uZXhjbHVkZVNwZWNQYXR0ZXJuLCAuLi5hZGRpdGlvbmFsSWdub3JlUGF0dGVybl0sXG4gICAgICB9XG4gICAgKTtcblxuICAgIHNwZWNBYnNvbHV0ZVBhdGhzID0gXy5pbnRlcnNlY3Rpb24oXG4gICAgICBzcGVjQWJzb2x1dGVQYXRocyxcbiAgICAgIGRlZmF1bHRTcGVjQWJzb2x1dGVQYXRoc1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlZFNwZWNzKHtcbiAgICBwcm9qZWN0Um9vdCxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBzcGVjQWJzb2x1dGVQYXRocyxcbiAgICBzcGVjUGF0dGVybixcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbGVzQnlHbG9iKFxuICBwcm9qZWN0Um9vdDogc3RyaW5nLFxuICBnbG9iOiBHbG9iUGF0dGVybixcbiAgZ2xvYk9wdGlvbnM6IEdsb2JieU9wdGlvbnNcbikge1xuICBjb25zdCB3b3JraW5nRGlyZWN0b3J5UHJlZml4ID0gcGF0aC5qb2luKHByb2plY3RSb290LCBwYXRoLnNlcCk7XG4gIGNvbnN0IGdsb2JzID0gKFtdIGFzIHN0cmluZ1tdKVxuICAgIC5jb25jYXQoZ2xvYilcbiAgICAubWFwKChnbG9iUGF0dGVybikgPT5cbiAgICAgIGdsb2JQYXR0ZXJuLnN0YXJ0c1dpdGgoXCIuL1wiKSA/IGdsb2JQYXR0ZXJuLnJlcGxhY2UoXCIuL1wiLCBcIlwiKSA6IGdsb2JQYXR0ZXJuXG4gICAgKVxuICAgIC5tYXAoKGdsb2JQYXR0ZXJuKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgcGF0dGVybiBpbmNsdWRlcyB0aGUgd29ya2luZyBkaXJlY3RvcnksIHdlIHN0cmlwIGl0IGZyb20gdGhlIHBhdHRlcm4uXG4gICAgICAvLyBUaGUgd29ya2luZyBkaXJlY3RvcnkgcGF0aCBtYXkgaW5jbHVkZSBjaGFyYWN0ZXJzIHRoYXQgY29uZmxpY3Qgd2l0aCBnbG9iXG4gICAgICAvLyBzeW50YXggKGJyYWNrZXRzLCBwYXJlbnRoZXNlcywgZXRjLikgYW5kIGNhdXNlIG91ciBzZWFyY2hlcyB0byBpbmFkdmVydGVudGx5IGZhaWwuXG4gICAgICAvLyBXZSBzY29wZSBvdXIgc2VhcmNoIHRvIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB1c2luZyB0aGUgYGN3ZGAgZ2xvYmJ5IG9wdGlvbi5cbiAgICAgIGlmIChnbG9iUGF0dGVybi5zdGFydHNXaXRoKHdvcmtpbmdEaXJlY3RvcnlQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiBnbG9iUGF0dGVybi5yZXBsYWNlKHdvcmtpbmdEaXJlY3RvcnlQcmVmaXgsIFwiXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2xvYlBhdHRlcm47XG4gICAgfSk7XG5cbiAgaWYgKG9zLnBsYXRmb3JtKCkgPT09IFwid2luMzJcIikge1xuICAgIC8vIGdsb2JieSBjYW4ndCB3b3JrIHdpdGggYmFja3dhcmRzIHNsYXNoZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dsb2JieS9pc3N1ZXMvMTc5XG4gICAgZGVidWcoXCJ1cGRhdGluZyBnbG9iIHBhdHRlcm5zIHRvIFBPU0lYXCIpO1xuICAgIGZvciAoY29uc3QgaSBpbiBnbG9icykge1xuICAgICAgY29uc3QgY3VyID0gZ2xvYnNbaV07XG5cbiAgICAgIGlmICghY3VyKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmRlZmluZWQgZ2xvYiByZWNlaXZlZFwiKTtcblxuICAgICAgZ2xvYnNbaV0gPSB0b1Bvc2l4KGN1cik7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZyhcImdsb2JiaW5nIHBhdHRlcm4ocyk6ICVvXCIsIGdsb2JzKTtcbiAgICBkZWJ1ZyhcIndpdGhpbiBkaXJlY3Rvcnk6ICVzXCIsIHByb2plY3RSb290KTtcblxuICAgIHJldHVybiBtYXRjaEdsb2JzKGdsb2JzLCB7XG4gICAgICBvbmx5RmlsZXM6IHRydWUsXG4gICAgICBhYnNvbHV0ZTogdHJ1ZSxcbiAgICAgIGN3ZDogcHJvamVjdFJvb3QsXG4gICAgICAuLi5nbG9iT3B0aW9ucyxcbiAgICAgIGlnbm9yZTogKGdsb2JPcHRpb25zPy5pZ25vcmUgPz8gW10pLmNvbmNhdChcIioqL25vZGVfbW9kdWxlcy8qKlwiKSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKFwiZXJyb3IgaW4gZ2V0RmlsZXNCeUdsb2IgJW9cIiwgZSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmNvbnN0IG1hdGNoR2xvYnMgPSBhc3luYyAoZ2xvYnM6IEdsb2JQYXR0ZXJuLCBnbG9iYnlPcHRpb25zOiBHbG9iYnlPcHRpb25zKSA9PiB7XG4gIHJldHVybiBhd2FpdCBnbG9iYnkoZ2xvYnMsIGdsb2JieU9wdGlvbnMpO1xufTtcblxuaW50ZXJmYWNlIE1hdGNoZWRTcGVjcyB7XG4gIHByb2plY3RSb290OiBzdHJpbmc7XG4gIHRlc3RpbmdUeXBlOiBUZXN0aW5nVHlwZTtcbiAgc3BlY0Fic29sdXRlUGF0aHM6IHN0cmluZ1tdO1xuICBzcGVjUGF0dGVybjogc3RyaW5nIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIG1hdGNoZWRTcGVjcyh7XG4gIHByb2plY3RSb290LFxuICB0ZXN0aW5nVHlwZSxcbiAgc3BlY0Fic29sdXRlUGF0aHMsXG59OiBNYXRjaGVkU3BlY3MpIHtcbiAgZGVidWcoXCJmb3VuZCBzcGVjcyAlb1wiLCBzcGVjQWJzb2x1dGVQYXRocyk7XG5cbiAgbGV0IGNvbW1vblJvb3QgPSBcIlwiO1xuXG4gIGlmIChzcGVjQWJzb2x1dGVQYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICBjb21tb25Sb290ID0gcGF0aC5kaXJuYW1lKHNwZWNBYnNvbHV0ZVBhdGhzWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBjb21tb25Sb290ID0gY29tbW9uUGF0aFByZWZpeChzcGVjQWJzb2x1dGVQYXRocyk7XG4gIH1cblxuICByZXR1cm4gc3BlY0Fic29sdXRlUGF0aHMubWFwKChhYnNvbHV0ZSkgPT5cbiAgICB0cmFuc2Zvcm1TcGVjKHtcbiAgICAgIHByb2plY3RSb290LFxuICAgICAgYWJzb2x1dGUsXG4gICAgICB0ZXN0aW5nVHlwZSxcbiAgICAgIGNvbW1vblJvb3QsXG4gICAgICBwbGF0Zm9ybTogb3MucGxhdGZvcm0oKSxcbiAgICAgIHNlcDogcGF0aC5zZXAsXG4gICAgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1TcGVjIHtcbiAgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgYWJzb2x1dGU6IHN0cmluZztcbiAgdGVzdGluZ1R5cGU6IFRlc3RpbmdUeXBlO1xuICBjb21tb25Sb290OiBzdHJpbmc7XG4gIHBsYXRmb3JtOiBOb2RlSlMuUGxhdGZvcm07XG4gIHNlcDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjKHtcbiAgcHJvamVjdFJvb3QsXG4gIGFic29sdXRlLFxuICB0ZXN0aW5nVHlwZSxcbiAgY29tbW9uUm9vdCxcbiAgcGxhdGZvcm0sXG4gIHNlcCxcbn06IFRyYW5zZm9ybVNwZWMpIHtcbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBhYnNvbHV0ZSA9IHRvUG9zaXgoYWJzb2x1dGUsIHNlcCk7XG4gICAgcHJvamVjdFJvb3QgPSB0b1Bvc2l4KHByb2plY3RSb290LCBzZXApO1xuICB9XG5cbiAgY29uc3QgcmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKHByb2plY3RSb290LCBhYnNvbHV0ZSk7XG4gIGNvbnN0IHBhcnNlZEZpbGUgPSBwYXRoLnBhcnNlKGFic29sdXRlKTtcbiAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShhYnNvbHV0ZSk7XG5cbiAgY29uc3Qgc3BlY0ZpbGVFeHRlbnNpb24gPVxuICAgIFtcIi5zcGVjXCIsIFwiLnRlc3RcIiwgXCItc3BlY1wiLCBcIi10ZXN0XCIsIFwiLmN5XCJdXG4gICAgICAubWFwKChleHQpID0+IGV4dCArIGZpbGVFeHRlbnNpb24pXG4gICAgICAuZmluZCgoZXh0KSA9PiBhYnNvbHV0ZS5lbmRzV2l0aChleHQpKSB8fCBmaWxlRXh0ZW5zaW9uO1xuXG4gIGNvbnN0IHBhcnRzID0gYWJzb2x1dGUuc3BsaXQocHJvamVjdFJvb3QpO1xuICBsZXQgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIHx8IFwiXCI7XG5cbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBuYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgfVxuXG4gIGNvbnN0IExFQURJTkdfU0xBU0ggPSAvXlxcL3wvZztcbiAgY29uc3QgcmVsYXRpdmVUb0NvbW1vblJvb3QgPSBhYnNvbHV0ZVxuICAgIC5yZXBsYWNlKGNvbW1vblJvb3QsIFwiXCIpXG4gICAgLnJlcGxhY2UoTEVBRElOR19TTEFTSCwgXCJcIik7XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlRXh0ZW5zaW9uLFxuICAgIGJhc2VOYW1lOiBwYXJzZWRGaWxlLmJhc2UsXG4gICAgZmlsZU5hbWU6IHBhcnNlZEZpbGUuYmFzZS5yZXBsYWNlKHNwZWNGaWxlRXh0ZW5zaW9uLCBcIlwiKSxcbiAgICBzcGVjRmlsZUV4dGVuc2lvbixcbiAgICByZWxhdGl2ZVRvQ29tbW9uUm9vdCxcbiAgICBzcGVjVHlwZTogKHRlc3RpbmdUeXBlID09PSBcImNvbXBvbmVudFwiXG4gICAgICA/IFwiY29tcG9uZW50XCJcbiAgICAgIDogXCJpbnRlZ3JhdGlvblwiKSBhcyBTcGVjVHlwZSxcbiAgICBuYW1lLFxuICAgIHJlbGF0aXZlLFxuICAgIGFic29sdXRlLFxuICB9O1xufVxuIiwgImltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KHZhbD86IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gIHJldHVybiB2YWwgPyAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IFt2YWxdIDogdmFsKSA6IFtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Qb3NpeChmaWxlOiBzdHJpbmcsIHNlcDogc3RyaW5nID0gcGF0aC5zZXApIHtcbiAgcmV0dXJuIGZpbGUuc3BsaXQoc2VwKS5qb2luKHBhdGgucG9zaXguc2VwKTtcbn1cbiIsICJpbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWcvY29uZmlnXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZmluZFNwZWNzIH0gZnJvbSBcIi4vc3BlY01hdGNoZXJcIjtcblxuZXhwb3J0IGNvbnN0IGdldFNwZWNGaWxlcyA9IGFzeW5jICh7XG4gIGNvbmZpZyxcbiAgcGFyYW1zLFxufToge1xuICBjb25maWc6IE1lcmdlZENvbmZpZztcbiAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG59KSA9PiB7XG4gIGNvbnN0IHNwZWNQYXR0ZXJuID0gZ2V0U3BlY1BhdHRlcm4oY29uZmlnLnNwZWNQYXR0ZXJuLCBwYXJhbXMuc3BlYyk7XG4gIC8vIGZpbmQgdGhlIHNwZWMgZmlsZXMgYWNjb3JkaW5nIHRvIHRoZSByZXNvbHZlZCBjb25maWd1cmF0aW9uXG4gIGNvbnN0IHNwZWNzID0gYXdhaXQgZmluZFNwZWNzKHtcbiAgICAvLyBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvZ3VpZGVzL2NvbW1hbmQtbGluZSNjeXByZXNzLXJ1bi1zcGVjLWx0LXNwZWMtZ3RcbiAgICBwcm9qZWN0Um9vdDogcGFyYW1zLnByb2plY3QgPz8gY29uZmlnLnByb2plY3RSb290LFxuICAgIHRlc3RpbmdUeXBlOiBwYXJhbXMudGVzdGluZ1R5cGUsXG4gICAgc3BlY1BhdHRlcm4sXG4gICAgY29uZmlnU3BlY1BhdHRlcm46IGNvbmZpZy5zcGVjUGF0dGVybixcbiAgICBleGNsdWRlU3BlY1BhdHRlcm46IGNvbmZpZy5leGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm46IGNvbmZpZy5hZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgfSk7XG4gIGlmIChzcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICB3YXJuKFxuICAgICAgXCJGb3VuZCBubyBzcGVjIGZpbGVzLiBXYXMgbG9va2luZyBmb3Igc3BlYyBmaWxlcyB0aGF0IG1hdGNoIGJvdGggY29uZmlnU3BlY1BhdHRlcm4gYW5kIHNwZWNQYXR0ZXJuIHJlbGF0aXZlIHRvIHByb2plY3RSb290LiBDb25maWd1cmF0aW9uOiAlT1wiLFxuICAgICAge1xuICAgICAgICBwcm9qZWN0Um9vdDogY29uZmlnLnByb2plY3RSb290LFxuICAgICAgICBzcGVjUGF0dGVybixcbiAgICAgICAgY29uZmlnU3BlY1BhdHRlcm46IGNvbmZpZy5zcGVjUGF0dGVybixcbiAgICAgICAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBbXG4gICAgICAgICAgY29uZmlnLmV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgICAgICAgICBjb25maWcuYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gICAgICAgIF0uZmxhdCgyKSxcbiAgICAgICAgdGVzdGluZ1R5cGU6IHBhcmFtcy50ZXN0aW5nVHlwZSxcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7IHNwZWNzLCBzcGVjUGF0dGVybiB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U3BlY1BhdHRlcm4oXG4gIGNvbmZpZ1BhdHRlcm46IE1lcmdlZENvbmZpZ1tcInNwZWNQYXR0ZXJuXCJdLFxuICBleHBsaWNpdD86IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInNwZWNcIl1cbikge1xuICByZXR1cm4gZXhwbGljaXQgfHwgY29uZmlnUGF0dGVybjtcbn1cbiIsICJleHBvcnQgY2xhc3MgQ29uZmlnU3RhdGUge1xuICBwcml2YXRlIF9jb25maWc6IEN5cHJlc3MuUmVzb2x2ZWRDb25maWdPcHRpb25zIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBwdWJsaWMgc2V0Q29uZmlnKGM6IHR5cGVvZiB0aGlzLl9jb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBjO1xuICB9XG4gIHB1YmxpYyBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEN5cHJlc3NSdW4sXG4gIEN5cHJlc3NTY3JlZW5zaG90LFxuICBDeXByZXNzVGVzdCxcbiAgQ3lwcmVzc1Rlc3RBdHRlbXB0LFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuXG5pbXBvcnQgKiBhcyBTcGVjQWZ0ZXIgZnJvbSBcIi4uL3J1bm5lci9zcGVjLnR5cGVcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5pbXBvcnQgeyBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24gfSBmcm9tIFwiLi9yZXN1bHRzXCI7XG5cbmZ1bmN0aW9uIGdldFNjcmVlbnNob3QoczogU3BlY0FmdGVyLlNjcmVlbnNob3QpOiBDeXByZXNzU2NyZWVuc2hvdCB7XG4gIHJldHVybiB7XG4gICAgLi4ucyxcbiAgICBuYW1lOiBzLm5hbWUgPz8gXCJzY3JlZW5zaG90XCIsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRlc3RBdHRlbXB0KFxuICBhdHRlbXB0OiBTcGVjQWZ0ZXIuVGVzdEF0dGVtcHQsXG4gIHNjcmVlbnNob3RzOiBTcGVjQWZ0ZXIuU2NyZWVuc2hvdFtdXG4pOiBDeXByZXNzVGVzdEF0dGVtcHQge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGVtcHQsXG4gICAgc3RhcnRlZEF0OiBhdHRlbXB0LndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICBkdXJhdGlvbjogYXR0ZW1wdC53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICBzY3JlZW5zaG90czogc2NyZWVuc2hvdHMubWFwKGdldFNjcmVlbnNob3QpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUZXN0KFxuICB0OiBTcGVjQWZ0ZXIuVGVzdCxcbiAgc2NyZWVuc2hvdHM6IFNwZWNBZnRlci5TY3JlZW5zaG90W11cbik6IEN5cHJlc3NUZXN0IHtcbiAgY29uc3QgX3NjcmVlbnNob3RzID0gc2NyZWVuc2hvdHMuZmlsdGVyKChzKSA9PiBzLnRlc3RJZCA9PT0gdC50ZXN0SWQpO1xuICByZXR1cm4ge1xuICAgIC4uLnQsXG4gICAgYXR0ZW1wdHM6IHQuYXR0ZW1wdHMubWFwKChhLCBpKSA9PlxuICAgICAgZ2V0VGVzdEF0dGVtcHQoXG4gICAgICAgIGEsXG4gICAgICAgIF9zY3JlZW5zaG90cy5maWx0ZXIoKHMpID0+IHMudGVzdEF0dGVtcHRJbmRleCA9PT0gaSlcbiAgICAgIClcbiAgICApLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHNwZWNBZnRlclJlc3VsdDogU3BlY0FmdGVyLlNwZWNSZXN1bHRcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnOiBjb25maWdTdGF0ZS5nZXRDb25maWcoKSxcbiAgICB0b3RhbER1cmF0aW9uOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgdG90YWxTdWl0ZXM6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5zdWl0ZXMsXG4gICAgdG90YWxUZXN0czogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnRlc3RzLFxuICAgIHRvdGFsRmFpbGVkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuZmFpbHVyZXMsXG4gICAgdG90YWxQYXNzZWQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5wYXNzZXMsXG4gICAgdG90YWxQZW5kaW5nOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMucGVuZGluZyxcbiAgICB0b3RhbFNraXBwZWQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5za2lwcGVkLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgIGVuZGVkVGVzdHNBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0VuZGVkQXQsXG4gICAgcnVuczogW1xuICAgICAge1xuICAgICAgICBzdGF0czoge1xuICAgICAgICAgIC4uLnNwZWNBZnRlclJlc3VsdC5zdGF0cyxcbiAgICAgICAgICBzdGFydGVkQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgICAgICAgZW5kZWRBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0VuZGVkQXQsXG4gICAgICAgICAgZHVyYXRpb246IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgcmVwb3J0ZXI6IHNwZWNBZnRlclJlc3VsdC5yZXBvcnRlcixcbiAgICAgICAgcmVwb3J0ZXJTdGF0czogc3BlY0FmdGVyUmVzdWx0LnJlcG9ydGVyU3RhdHMgPz8ge30sXG4gICAgICAgIHNwZWM6IHNwZWNBZnRlclJlc3VsdC5zcGVjLFxuICAgICAgICBlcnJvcjogc3BlY0FmdGVyUmVzdWx0LmVycm9yLFxuICAgICAgICB2aWRlbzogc3BlY0FmdGVyUmVzdWx0LnZpZGVvLFxuICAgICAgICBzaG91bGRVcGxvYWRWaWRlbzogdHJ1ZSwgLy8gbm90IHJlYWxseSB1c2VkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gd3JvbmcgdHlwZWRlZiBmb3IgQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbiAgICAgICAgLy8gYWN0dWFsIEhvb2tOYW1lIGlzIFwiYmVmb3JlIGFsbFwiIHwgXCJiZWZvcmUgZWFjaFwiIHwgXCJhZnRlciBhbGxcIiB8IFwiYWZ0ZXIgZWFjaFwiXG4gICAgICAgIGhvb2tzOiBzcGVjQWZ0ZXJSZXN1bHQuaG9va3MsXG4gICAgICAgIHRlc3RzOiAoc3BlY0FmdGVyUmVzdWx0LnRlc3RzID8/IFtdKS5tYXAoKHQpID0+XG4gICAgICAgICAgZ2V0VGVzdCh0LCBzcGVjQWZ0ZXJSZXN1bHQuc2NyZWVuc2hvdHMpXG4gICAgICAgICksXG4gICAgICB9LFxuICAgIF0sXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBiYWNrZmlsbEV4Y2VwdGlvbiA9IChcbiAgcmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFxuKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdWx0LFxuICAgIHJ1bnM6IHJlc3VsdC5ydW5zLm1hcChiYWNrZmlsbEV4Y2VwdGlvblJ1biksXG4gIH07XG59O1xuXG5jb25zdCBiYWNrZmlsbEV4Y2VwdGlvblJ1biA9IChydW46IEN5cHJlc3NSdW4pID0+IHtcbiAgaWYgKCFydW4uZXJyb3IpIHtcbiAgICByZXR1cm4gcnVuO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ydW4sXG4gICAgdGVzdHM6IFtnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24ocnVuLmVycm9yLCBydW4uc3RhdHMpXSxcbiAgfTtcbn07XG4iLCAiaW1wb3J0IHsgSW5zdGFuY2VJZCB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBlcnJvciwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEZhaWxlZER1bW15UmVzdWx0IH0gZnJvbSBcIi4uL3Jlc3VsdHNcIjtcbmltcG9ydCB7XG4gIGJhY2tmaWxsRXhjZXB0aW9uLFxuICBzcGVjUmVzdWx0c1RvQ3lwcmVzc1Jlc3VsdHMsXG59IGZyb20gXCIuLi9yZXN1bHRzL21hcFJlc3VsdFwiO1xuaW1wb3J0IHsgU3BlY1Jlc3VsdCB9IGZyb20gXCIuLi9ydW5uZXIvc3BlYy50eXBlXCI7XG5cbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6c3RhdGVcIik7XG5cbnR5cGUgSW5zdGFuY2VFeGVjdXRpb25TdGF0ZSA9IHtcbiAgaW5zdGFuY2VJZDogSW5zdGFuY2VJZDtcbiAgc3BlYzogc3RyaW5nO1xuICBvdXRwdXQ/OiBzdHJpbmc7XG4gIHNwZWNCZWZvcmU/OiBEYXRlO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHJ1blJlc3VsdHM/OiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdDtcbiAgcnVuUmVzdWx0c1JlcG9ydGVkQXQ/OiBEYXRlO1xuICBzcGVjQWZ0ZXI/OiBEYXRlO1xuICBzcGVjQWZ0ZXJSZXN1bHRzPzogU3BlY1Jlc3VsdDtcbiAgcmVwb3J0U3RhcnRlZEF0PzogRGF0ZTtcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBjbGFzcyBFeGVjdXRpb25TdGF0ZSB7XG4gIHByaXZhdGUgd2FybmluZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBzdGF0ZTogUmVjb3JkPEluc3RhbmNlSWQsIEluc3RhbmNlRXhlY3V0aW9uU3RhdGU+ID0ge307XG5cbiAgcHVibGljIGdldFdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLndhcm5pbmdzO1xuICB9XG5cbiAgcHVibGljIGFkZFdhcm5pbmcod2FybmluZzogc3RyaW5nKSB7XG4gICAgdGhpcy53YXJuaW5ncy5hZGQod2FybmluZyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVzdWx0cyhjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlKS5tYXAoKGkpID0+XG4gICAgICB0aGlzLmdldEluc3RhbmNlUmVzdWx0cyhjb25maWdTdGF0ZSwgaS5pbnN0YW5jZUlkKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZDogSW5zdGFuY2VJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWMoc3BlYzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZSkuZmluZCgoaSkgPT4gaS5zcGVjID09PSBzcGVjKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0SW5zdGFuY2Uoe1xuICAgIGluc3RhbmNlSWQsXG4gICAgc3BlYyxcbiAgfToge1xuICAgIGluc3RhbmNlSWQ6IEluc3RhbmNlSWQ7XG4gICAgc3BlYzogc3RyaW5nO1xuICB9KSB7XG4gICAgZGVidWcoJ0luaXQgZXhlY3V0aW9uIHN0YXRlIGZvciBcIiVzXCInLCBzcGVjKTtcbiAgICB0aGlzLnN0YXRlW2luc3RhbmNlSWRdID0ge1xuICAgICAgaW5zdGFuY2VJZCxcbiAgICAgIHNwZWMsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjQmVmb3JlKHNwZWM6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaS5zcGVjQmVmb3JlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjQ292ZXJhZ2Uoc3BlYzogc3RyaW5nLCBjb3ZlcmFnZUZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlYnVnKFwiRXhwZXJpbWVudGFsOiBjb3ZlcmFnZUZpbGVQYXRoIHdhcyBzZXRcIik7XG4gICAgaS5jb3ZlcmFnZUZpbGVQYXRoID0gY292ZXJhZ2VGaWxlUGF0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjQWZ0ZXIoc3BlYzogc3RyaW5nLCByZXN1bHRzOiBTcGVjUmVzdWx0KSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaS5zcGVjQWZ0ZXIgPSBuZXcgRGF0ZSgpO1xuICAgIGkuc3BlY0FmdGVyUmVzdWx0cyA9IHJlc3VsdHM7XG4gIH1cblxuICBwdWJsaWMgc2V0U3BlY091dHB1dChzcGVjOiBzdHJpbmcsIG91dHB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRJbnN0YW5jZU91dHB1dChpLmluc3RhbmNlSWQsIG91dHB1dCk7XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VPdXRwdXQoaW5zdGFuY2VJZDogc3RyaW5nLCBvdXRwdXQ6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSBcIiVzXCInLCBpbnN0YW5jZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkub3V0cHV0KSB7XG4gICAgICBkZWJ1ZygnSW5zdGFuY2UgXCIlc1wiIGFscmVhZHkgaGFzIG91dHB1dCcsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLm91dHB1dCA9IG91dHB1dDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnN0YW5jZVJlc3VsdChcbiAgICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gICAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICAgIHJlc3VsdHM6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0XG4gICkge1xuICAgIGNvbnN0IGkgPSB0aGlzLnN0YXRlW2luc3RhbmNlSWRdO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZSBcIiVzXCInLCBpbnN0YW5jZUlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaS5ydW5SZXN1bHRzID0gcmVzdWx0cztcbiAgICBpLnJ1blJlc3VsdHNSZXBvcnRlZEF0ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnN0YW5jZVJlc3VsdHMoXG4gICAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICAgIGluc3RhbmNlSWQ6IHN0cmluZ1xuICApOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZCk7XG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIGVycm9yKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuXG4gICAgICByZXR1cm4gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoY29uZmlnU3RhdGUsIHtcbiAgICAgICAgc3BlY3M6IFtcInVua25vd25cIl0sXG4gICAgICAgIGVycm9yOiBcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2VcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVzZSBzcGVjOmFmdGVyIHJlc3VsdHMgLSBpdCBjYW4gYmVjb21lIGF2YWlsYWJsZSBiZWZvcmUgcnVuIHJlc3VsdHNcbiAgICBpZiAoaS5zcGVjQWZ0ZXJSZXN1bHRzKSB7XG4gICAgICByZXR1cm4gYmFja2ZpbGxFeGNlcHRpb24oXG4gICAgICAgIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyhjb25maWdTdGF0ZSwgaS5zcGVjQWZ0ZXJSZXN1bHRzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaS5ydW5SZXN1bHRzKSB7XG4gICAgICByZXR1cm4gYmFja2ZpbGxFeGNlcHRpb24oaS5ydW5SZXN1bHRzKTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnTm8gcmVzdWx0cyBkZXRlY3RlZCBmb3IgXCIlc1wiJywgaS5zcGVjKTtcbiAgICByZXR1cm4gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoY29uZmlnU3RhdGUsIHtcbiAgICAgIHNwZWNzOiBbaS5zcGVjXSxcbiAgICAgIGVycm9yOiBgTm8gcmVzdWx0cyBkZXRlY3RlZCBmb3IgdGhlIHNwZWMgZmlsZS4gVGhhdCB1c3VhbGx5IGhhcHBlbnMgYmVjYXVzZSBvZiBjeXByZXNzIGNyYXNoLiBTZWUgdGhlIGNvbnNvbGUgb3V0cHV0IGZvciBkZXRhaWxzLmAsXG4gICAgfSk7XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxhQUFBQTtBQUFBO0FBQUE7OztBQ0tBLElBQU0sbUJBQW1CLE1BQ3ZCLE9BQU8sYUFBYSxjQUNoQixJQUFJLElBQUksVUFBVSxVQUFVLEVBQUUsT0FDN0IsU0FBUyxpQkFBaUIsU0FBUyxjQUFjLE9BQ2xELElBQUksSUFBSSxXQUFXLFNBQVMsT0FBTyxFQUFFO0FBRXBDLElBQU0sZ0JBQWdDLGlDQUFpQjs7O0FEVjlELHNCQUFPOzs7QUVEUCxvQkFBOEI7QUFFdkIsSUFBTUMsZUFBVSw2QkFBYyxhQUFlOzs7QUNGcEQsMkJBQWU7QUFDZixJQUFNLFVBQVUscUJBQUFDLFFBQUc7QUFHbkIscUJBQUFBLFFBQUcsUUFBUSxTQUFVLFNBQVMsTUFBTSxTQUFTO0FBRTNDLE1BQUksUUFBUSxNQUFNLFNBQVMsR0FBRztBQUU1QixVQUFNQyxXQUFVLFFBQVEsU0FBUyxNQUFNO0FBQUEsTUFDckMsR0FBRztBQUFBO0FBQUEsTUFFSCxPQUFPLENBQUMsUUFBUSxRQUFRLE1BQU07QUFBQSxJQUNoQyxDQUFDO0FBQ0QsV0FBT0E7QUFBQSxFQUNUO0FBR0EsU0FBTyxRQUFRLFNBQVMsTUFBTSxPQUFPO0FBQ3ZDOzs7QUNsQkEsbUJBQWtCO0FBQ2xCLGtCQUFpQjtBQUVqQixpQ0FBMkI7QUFDM0Isd0JBQXlCO0FBQ3pCLGdCQUEyQjs7O0FDTDNCLG9CQUF5QjtBQUlsQixJQUFNLFNBQVMsSUFBSSxjQUFBQyxRQUFhOzs7QURJdkMsSUFBTSxZQUFRLGFBQUFDLFNBQU0sYUFBYTtBQUVqQyxJQUFJLFNBQTZCO0FBQ2pDLElBQUksTUFBK0I7QUFDbkMsSUFBSSxpQkFBd0M7QUFFckMsSUFBTSxhQUFhLFVBQ3hCLHlCQUFNLFFBQVEsUUFBUSxDQUFDLEVBQ3BCLEtBQUssRUFBRSxNQUFNLG9CQUFF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QTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQSxNQUVBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQSxNQUNBO0FBQUE7QUFBQTtBQUFBLE1BRUE7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsVUFBVTtBQUFBLElBQ1YsZ0JBQWdCLFFBQVE7QUFBQSxNQUN0QjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxRQUFRLFFBQVE7QUFBQSxNQUNkO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBLElBQ0QsU0FBUztBQUFBO0FBQUEsSUFFVCxTQUFTLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQTtBQUFBLElBRUQsU0FBUyxRQUFRO0FBQUEsTUFDZjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFDRjtBQUlBLElBQU0sd0JBQXdCLE1BQStCO0FBQzNELFFBQU0sRUFBRSxJQUFJLElBQUk7QUFFaEIsU0FBTztBQUFBLElBQ0wsVUFBVTtBQUFBLE1BQ1IsS0FBSyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7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ZTtBQUFBLFlBQ2Isb0NBQW9DQTtBQUFBLEVBQVUsSUFBSUMsTUFBSztBQUFBLFVBQ3pEO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSwyQkFBcUIsYUFBYSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsSUFDakU7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxTQUFTRixlQUFjLGdCQUFnQztBQUNyRCxRQUFNLFdBQVcsTUFBTSxLQUFLLGVBQWUsWUFBWSxDQUFDO0FBQ3hELE1BQUksU0FBUyxTQUFTLEdBQUc7QUFDdkI7QUFBQSxNQUNFLEdBQUcsU0FBUyxjQUFVLFlBQUFHO0FBQUEsUUFDcEI7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYO0FBQUEsRUFBd0MsU0FDckMsSUFBSSxDQUFDLEdBQUcsTUFBTTtBQUFBLEVBQUssT0FBTyxJQUFJLElBQUksS0FBSyxTQUFTLFNBQVMsS0FBSyxHQUFHLEVBQ2pFLEtBQUssSUFBSTtBQUFBLElBQ2Q7QUFBQSxFQUNGO0FBQ0Y7OztBbkJ4TU8sU0FBU0MsS0FBSSxRQUF5QjtBQUMzQyxTQUFPLElBQVksTUFBTTtBQUMzQjsiLAogICJuYW1lcyI6IFsicnVuIiwgInJlcXVpcmUiLCAiY3AiLCAicHJvY2VzcyIsICJFdmVudEVtaXR0ZXIiLCAiRGVidWciLCAiZXJyb3IiLCAiaHR0cCIsICJIdHRwVGVybWluYXRvciIsICJpbXBvcnRfZGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAibG9nIiwgImltcG9ydF9heGlvcyIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2xvZGFzaCIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X3RzX3BhdHRlcm4iLCAiaW1wb3J0X2RlYnVnIiwgInBhdGgiLCAidXRpbCIsICJjaGFsayIsICJ1dGlsIiwgImNoYWxrIiwgImltcG9ydF9kZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgInJlcXVpcmUiLCAic3Rkb3V0IiwgImZzIiwgImV4ZWNhIiwgImltcG9ydF9sb2Rhc2giLCAiXyIsICJpc0Fic29sdXRlIiwgInBhdGgiLCAiZGVidWciLCAiRGVidWciLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9sb2Rhc2giLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJpbXBvcnRfbG9kYXNoIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiYXhpb3MiLCAiXyIsICJheGlvc1JldHJ5IiwgInByZXR0eU1pbGxpc2Vjb25kcyIsICJlcnJvciIsICJyZXF1aXJlIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfbG9kYXNoIiwgIl8iLCAicGxhdGZvcm0iLCAic3Rkb3V0IiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfbG9kYXNoIiwgImRlYnVnIiwgImRlYnVnRm4iLCAiXyIsICJfIiwgImRlYnVnIiwgImltcG9ydF9wYXRoIiwgInBhdGgiLCAiZnMiLCAiZXJyb3IiLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9sb2Rhc2giLCAiYmx1ZWJpcmQiLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJjeXByZXNzIiwgImVycm9yIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfdHNfcGF0dGVybiIsICJkZWJ1ZyIsICJpbXBvcnRfZGVidWciLCAiZGVidWciLCAiRGVidWciLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF91dGlsIiwgImRlYnVnIiwgIkRlYnVnIiwgImdldG9zIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfbG9kYXNoIiwgImltcG9ydF9uYW5vaWQiLCAiZGVidWciLCAiRGVidWciLCAiZXJyb3IiLCAiXyIsICJydW4iLCAiaW1wb3J0X2xvZGFzaCIsICJpbXBvcnRfcHJldHR5X21zIiwgIl8iLCAiciIsICJwcmV0dHlNUyIsICJpbXBvcnRfZGVidWciLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfZnMiLCAiZnMiLCAiZGVidWciLCAiRGVidWciLCAiZmlsZSIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJzdGRvdXQiLCAicnVuIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfZGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicGxhdGZvcm0iLCAiZXJyb3IiLCAiaW1wb3J0X2RlYnVnIiwgImltcG9ydF9wYXRoIiwgImltcG9ydF9sb2Rhc2giLCAiaW1wb3J0X29zIiwgImltcG9ydF9wYXRoIiwgImZpbGUiLCAicGF0aCIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgInBhdGgiLCAib3MiLCAiZ2xvYmJ5IiwgImNvbW1vblBhdGhQcmVmaXgiLCAicGxhdGZvcm0iLCAiZ2V0VGVzdEF0dGVtcHQiLCAicnVuIiwgImltcG9ydF9kZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJwbGF0Zm9ybSIsICJydW4iLCAicHJpbnRXYXJuaW5ncyIsICJwYXRoIiwgImVycm9yIiwgInBsdXIiLCAicnVuIl0KfQo=